
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>neurodent.core.core &#8212; Neurodent 0.2.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=938c9ccc"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/neurodent/core/core';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://josephdong1000.github.io/neurodent/_static/switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '0.2.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Neurodent</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation/index.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../quickstart/index.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API Reference
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../license/index.html">
    License
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/josephdong1000/neurodent" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/neurodent/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation/index.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../quickstart/index.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../license/index.html">
    License
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/josephdong1000/neurodent" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/neurodent/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">neurodent.core.core</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for neurodent.core.core</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gzip</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">statistics</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">dask</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pragma: no cover - optional at import time for tests that don&#39;t use dask</span>
    <span class="n">dask</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">mne</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">spikeinterface.core</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">si</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">spikeinterface.extractors</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">se</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">spikeinterface.preprocessing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">spre</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">spikeinterface.widgets</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sw</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pragma: no cover - optional at import time for tests not using spikeinterface</span>
    <span class="n">si</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">se</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">spre</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">sw</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">decimate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">LocalOutlierFactor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..</span><span class="w"> </span><span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Natural_Neighbor</span><span class="p">,</span>
    <span class="n">TimestampMapper</span><span class="p">,</span>
    <span class="n">convert_colpath_to_rowpath</span><span class="p">,</span>
    <span class="n">convert_units_to_multiplier</span><span class="p">,</span>
    <span class="n">extract_mne_unit_info</span><span class="p">,</span>
    <span class="n">filepath_to_index</span><span class="p">,</span>
    <span class="n">get_temp_directory</span><span class="p">,</span>
    <span class="n">parse_truncate</span><span class="p">,</span>
    <span class="n">get_file_stem</span><span class="p">,</span>
    <span class="n">should_use_cache_unified</span><span class="p">,</span>
    <span class="n">get_cache_status_message</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="DDFBinaryMetadata">
<a class="viewcode-back" href="../../../api/core/ddf_binary_metadata.html#neurodent.core.DDFBinaryMetadata">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DDFBinaryMetadata</span><span class="p">:</span>
<div class="viewcode-block" id="DDFBinaryMetadata.__init__">
<a class="viewcode-back" href="../../../api/core/ddf_binary_metadata.html#neurodent.core.DDFBinaryMetadata.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">metadata_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">n_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">f_s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dt_end</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channel_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">V_units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mult_to_uV</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize DDFBinaryMetadata either from a file path or direct parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            metadata_path (str, optional): Path to metadata CSV file. If provided, other parameters are ignored.</span>
<span class="sd">            n_channels (int, optional): Number of channels</span>
<span class="sd">            f_s (float, optional): Sampling frequency in Hz</span>
<span class="sd">            dt_end (datetime, optional): End datetime of recording</span>
<span class="sd">            channel_names (list, optional): List of channel names</span>
<span class="sd">            V_units (str, optional): Voltage units (e.g., &#39;µV&#39;, &#39;mV&#39;, &#39;V&#39;)</span>
<span class="sd">            mult_to_uV (float, optional): Multiplication factor to convert to microvolts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_path</span><span class="p">(</span><span class="n">metadata_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_params</span><span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">f_s</span><span class="p">,</span> <span class="n">dt_end</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">V_units</span><span class="p">,</span> <span class="n">mult_to_uV</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_init_from_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata_path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_path</span> <span class="o">=</span> <span class="n">metadata_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">metadata_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata file is empty: </span><span class="si">{</span><span class="n">metadata_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getsinglecolval</span><span class="p">(</span>
            <span class="s2">&quot;SampleRate&quot;</span>
        <span class="p">)</span>  <span class="c1"># NOTE this may not be the same as LongRecording (Recording object) f_s, which the name should reflect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getsinglecolval</span><span class="p">(</span><span class="s2">&quot;Units&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mult_to_uV</span> <span class="o">=</span> <span class="n">convert_units_to_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getsinglecolval</span><span class="p">(</span><span class="s2">&quot;Precision&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;LastEdit&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_df</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt_end</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getsinglecolval</span><span class="p">(</span><span class="s2">&quot;LastEdit&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt_end</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No LastEdit column provided in metadata. dt_end set to None&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_df</span><span class="p">[</span><span class="s2">&quot;ProbeInfo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_from_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">f_s</span><span class="p">,</span> <span class="n">dt_end</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">V_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mult_to_uV</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">f_s</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All parameters must be provided when not using metadata_path&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span> <span class="o">=</span> <span class="n">n_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_s</span> <span class="o">=</span> <span class="n">f_s</span>  <span class="c1"># NOTE see above note about f_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_units</span> <span class="o">=</span> <span class="n">V_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mult_to_uV</span> <span class="o">=</span> <span class="n">mult_to_uV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt_end</span> <span class="o">=</span> <span class="n">dt_end</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;channel_names must be a list&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="n">channel_names</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getsinglecolval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">):</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">colname</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vals</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not all </span><span class="si">{</span><span class="n">colname</span><span class="si">}</span><span class="s2">s are equal!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">vals</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="DDFBinaryMetadata.to_dict">
<a class="viewcode-back" href="../../../api/core/ddf_binary_metadata.html#neurodent.core.DDFBinaryMetadata.to_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert DDFBinaryMetadata to a dictionary for JSON serialization.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;metadata_path&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_path</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_path</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;n_channels&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
            <span class="s2">&quot;f_s&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_s</span><span class="p">,</span>
            <span class="s2">&quot;V_units&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_units</span><span class="p">,</span>
            <span class="s2">&quot;mult_to_uV&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mult_to_uV</span><span class="p">,</span>
            <span class="s2">&quot;precision&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
            <span class="s2">&quot;dt_end&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt_end</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt_end</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;channel_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="DDFBinaryMetadata.from_dict">
<a class="viewcode-back" href="../../../api/core/ddf_binary_metadata.html#neurodent.core.DDFBinaryMetadata.from_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DDFBinaryMetadata&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create DDFBinaryMetadata from a dictionary (from JSON deserialization).&quot;&quot;&quot;</span>
        <span class="n">dt_end</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt_end&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt_end&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">metadata_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># We&#39;re reconstructing from cached data</span>
            <span class="n">n_channels</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;n_channels&quot;</span><span class="p">],</span>
            <span class="n">f_s</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;f_s&quot;</span><span class="p">],</span>
            <span class="n">dt_end</span><span class="o">=</span><span class="n">dt_end</span><span class="p">,</span>
            <span class="n">channel_names</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;channel_names&quot;</span><span class="p">],</span>
            <span class="n">V_units</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;V_units&quot;</span><span class="p">),</span>
            <span class="n">mult_to_uV</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mult_to_uV&quot;</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DDFBinaryMetadata.to_json">
<a class="viewcode-back" href="../../../api/core/ddf_binary_metadata.html#neurodent.core.DDFBinaryMetadata.to_json">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save DDFBinaryMetadata to a JSON file.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="DDFBinaryMetadata.from_json">
<a class="viewcode-back" href="../../../api/core/ddf_binary_metadata.html#neurodent.core.DDFBinaryMetadata.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DDFBinaryMetadata&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load DDFBinaryMetadata from a JSON file.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># Reconstruct the object, preserving additional fields that were serialized</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Set additional fields that might not be in from_dict</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">V_units</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;V_units&quot;</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">mult_to_uV</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mult_to_uV&quot;</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;precision&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">instance</span></div>


<div class="viewcode-block" id="DDFBinaryMetadata.update_sampling_rate">
<a class="viewcode-back" href="../../../api/core/ddf_binary_metadata.html#neurodent.core.DDFBinaryMetadata.update_sampling_rate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_sampling_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_f_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the sampling rate in this metadata object.</span>

<span class="sd">        This should be called when the associated recording is resampled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_f_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_s</span> <span class="o">=</span> <span class="n">new_f_s</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updated DDFBinaryMetadata sampling rate from </span><span class="si">{</span><span class="n">old_f_s</span><span class="si">}</span><span class="s2"> Hz to </span><span class="si">{</span><span class="n">new_f_s</span><span class="si">}</span><span class="s2"> Hz&quot;</span><span class="p">)</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">convert_ddfcolbin_to_ddfrowbin</span><span class="p">(</span><span class="n">rowdir_path</span><span class="p">,</span> <span class="n">colbin_path</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">save_gzip</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># TODO consider renaming this function to something more descriptive, like convert_colbin_to_rowbin</span>
    <span class="c1"># Also don&#39;t use the rowdir_path parameter, since this is outside the scope of the function. See utils.convert_colpath_to_rowpath</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">DDFBinaryMetadata</span><span class="p">),</span> <span class="s2">&quot;Metadata needs to be of type DDFBinaryMetadata&quot;</span>

    <span class="n">tempbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">colbin_path</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">metadata</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>
    <span class="n">tempbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tempbin</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">metadata</span><span class="o">.</span><span class="n">n_channels</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

    <span class="n">rowbin_path</span> <span class="o">=</span> <span class="n">convert_colpath_to_rowpath</span><span class="p">(</span><span class="n">rowdir_path</span><span class="p">,</span> <span class="n">colbin_path</span><span class="p">,</span> <span class="n">gzip</span><span class="o">=</span><span class="n">save_gzip</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_gzip</span><span class="p">:</span>
        <span class="c1"># rowbin_path = str(rowbin_path) + &quot;.npy.gz&quot;</span>
        <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">rowbin_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fcomp</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">fcomp</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">tempbin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># rowbin_path = str(rowbin_path) + &quot;.bin&quot;</span>
        <span class="n">tempbin</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">rowbin_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rowbin_path</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convert_ddfrowbin_to_si</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a row-major binary file to a SpikeInterface recording object.</span>

<span class="sd">    Args:</span>
<span class="sd">        bin_rowmajor_path (str): Path to the row-major binary file</span>
<span class="sd">        metadata (DDFBinaryMetadata): Metadata object containing information about the recording</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - se.BaseRecording: The SpikeInterface Recording object.</span>
<span class="sd">            - str or None: Path to temporary file if created, None otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">se</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;SpikeInterface is required for convert_ddfrowbin_to_si&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">DDFBinaryMetadata</span><span class="p">),</span> <span class="s2">&quot;Metadata needs to be of type DDFBinaryMetadata&quot;</span>

    <span class="n">bin_rowmajor_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;sampling_frequency&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">f_s</span><span class="p">,</span>
        <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
        <span class="s2">&quot;num_channels&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
        <span class="s2">&quot;gain_to_uV&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">mult_to_uV</span><span class="p">,</span>
        <span class="s2">&quot;offset_to_uV&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;time_axis&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;is_filtered&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Read either .npy.gz files or .bin files into the recording object</span>
    <span class="k">if</span> <span class="s2">&quot;.npy.gz&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">):</span>
        <span class="n">temppath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">get_temp_directory</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">temppath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fcomp</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="n">bin_rowmajor_decomp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fcomp</span><span class="p">)</span>
                    <span class="n">bin_rowmajor_decomp</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">EOFError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Failed to read .npy.gz file: </span><span class="si">{</span><span class="n">bin_rowmajor_path</span><span class="si">}</span><span class="s2">. Try regenerating row-major files.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span>

            <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_binary</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Clean up temp file if it exists</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">temppath</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temppath</span><span class="p">)</span>
            <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_binary</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="n">temppath</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">sampling_frequency</span> <span class="o">!=</span> <span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sampling rate </span><span class="si">{</span><span class="n">rec</span><span class="o">.</span><span class="n">sampling_frequency</span><span class="si">}</span><span class="s2"> Hz != </span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="si">}</span><span class="s2"> Hz. Resampling&quot;</span><span class="p">)</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">spre</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="p">)</span>
        <span class="c1"># Update metadata to reflect the new sampling rate</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">update_sampling_rate</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="p">)</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="n">spre</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_DTYPE</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">,</span> <span class="n">temppath</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_convert_ddfrowbin_to_si_no_resample</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a row-major binary file to a SpikeInterface recording object WITHOUT resampling.</span>

<span class="sd">    This is an internal function used by the unified resampling pipeline to avoid</span>
<span class="sd">    resampling individual recordings before concatenation. Resampling is applied</span>
<span class="sd">    once after concatenation for better performance.</span>

<span class="sd">    Args:</span>
<span class="sd">        bin_rowmajor_path (str): Path to the row-major binary file</span>
<span class="sd">        metadata (DDFBinaryMetadata): Metadata object containing information about the recording</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - se.BaseRecording: The SpikeInterface Recording object (NOT resampled).</span>
<span class="sd">            - str or None: Path to temporary file if created, None otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">se</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;SpikeInterface is required for _convert_ddfrowbin_to_si_no_resample&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">DDFBinaryMetadata</span><span class="p">),</span> <span class="s2">&quot;Metadata needs to be of type DDFBinaryMetadata&quot;</span>

    <span class="n">bin_rowmajor_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;sampling_frequency&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">f_s</span><span class="p">,</span>
        <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
        <span class="s2">&quot;num_channels&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
        <span class="s2">&quot;gain_to_uV&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">mult_to_uV</span><span class="p">,</span>
        <span class="s2">&quot;offset_to_uV&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;time_axis&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;is_filtered&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Read either .npy.gz files or .bin files into the recording object</span>
    <span class="k">if</span> <span class="s2">&quot;.npy.gz&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">):</span>
        <span class="n">temppath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">get_temp_directory</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">temppath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fcomp</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="n">bin_rowmajor_decomp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fcomp</span><span class="p">)</span>
                    <span class="n">bin_rowmajor_decomp</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">EOFError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Failed to read .npy.gz file: </span><span class="si">{</span><span class="n">bin_rowmajor_path</span><span class="si">}</span><span class="s2">. Try regenerating row-major files.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span>

            <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_binary</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Clean up temp file if it exists</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">temppath</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temppath</span><span class="p">)</span>
            <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_binary</span><span class="p">(</span><span class="n">bin_rowmajor_path</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="n">temppath</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># NOTE: No resampling applied here - will be handled by unified resampling after concatenation</span>
    <span class="n">rec</span> <span class="o">=</span> <span class="n">spre</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_DTYPE</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">,</span> <span class="n">temppath</span>


<div class="viewcode-block" id="LongRecordingOrganizer">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LongRecordingOrganizer</span><span class="p">:</span>
<div class="viewcode-block" id="LongRecordingOrganizer.__init__">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base_folder_path</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;bin&quot;</span><span class="p">,</span> <span class="s2">&quot;si&quot;</span><span class="p">,</span> <span class="s2">&quot;mne&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bin&quot;</span><span class="p">,</span>
        <span class="n">truncate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cache_policy</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="s2">&quot;force_regenerate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">,</span>
        <span class="n">extract_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;si.BaseRecording&quot;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">input_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;folder&quot;</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;folder&quot;</span><span class="p">,</span>
        <span class="n">file_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">manual_datetimes</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">datetimes_are_start</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a long recording from binary files or EDF files.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_folder_path (str): Path to the base folder containing the data files.</span>
<span class="sd">            mode (Literal[&#39;bin&#39;, &#39;si&#39;, &#39;mne&#39;, None]): Mode to load data in. Defaults to &#39;bin&#39;.</span>
<span class="sd">            truncate (Union[bool, int], optional): If True, truncate data to first 10 files.</span>
<span class="sd">                If an integer, truncate data to the first n files. Defaults to False.</span>
<span class="sd">            overwrite_rowbins (bool, optional): If True, overwrite existing row-major binary files. Defaults to False.</span>
<span class="sd">            multiprocess_mode (Literal[&#39;dask&#39;, &#39;serial&#39;], optional): Processing mode for parallel operations. Defaults to &#39;serial&#39;.</span>
<span class="sd">            extract_func (Callable, optional): Function to extract data when using &#39;si&#39; or &#39;mne&#39; mode. Required for those modes.</span>
<span class="sd">            input_type (Literal[&#39;folder&#39;, &#39;file&#39;, &#39;files&#39;], optional): Type of input to load. Defaults to &#39;folder&#39;.</span>
<span class="sd">            file_pattern (str, optional): Pattern to match files when using &#39;file&#39; or &#39;files&#39; input type. Defaults to &#39;*&#39;.</span>
<span class="sd">            manual_datetimes (datetime | list[datetime], optional): Manual timestamps for the recording.</span>
<span class="sd">                For &#39;bin&#39; mode: if datetime, used as global start/end time; if list, one timestamp per file.</span>
<span class="sd">                For &#39;si&#39;/&#39;mne&#39; modes: if datetime, used as start/end of entire recording; if list, one per input file.</span>
<span class="sd">            datetimes_are_start (bool, optional): If True, manual_datetimes are treated as start times.</span>
<span class="sd">                If False, treated as end times. Defaults to True.</span>
<span class="sd">            n_jobs (int, optional): Number of jobs for MNE resampling operations. Defaults to 1 for safety.</span>
<span class="sd">                Set to -1 for automatic parallel detection, or &gt;1 for specific job count.</span>
<span class="sd">            **kwargs: Additional arguments passed to the data loading functions.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If no data files are found, if the folder contains mixed file types,</span>
<span class="sd">                or if manual time parameters are invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">base_folder_path</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_truncate</span> <span class="o">=</span> <span class="n">parse_truncate</span><span class="p">(</span><span class="n">truncate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truncate</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_truncate</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LongRecording will be truncated to the first </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_truncate</span><span class="si">}</span><span class="s2"> files&quot;</span><span class="p">)</span>

        <span class="c1"># Store manual time parameters for validation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span> <span class="o">=</span> <span class="n">manual_datetimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes_are_start</span> <span class="o">=</span> <span class="n">datetimes_are_start</span>

        <span class="c1"># Store n_jobs parameter for MNE operations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>

        <span class="c1"># Validate manual time parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_manual_time_params</span><span class="p">()</span>

        <span class="c1"># Initialize core attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temppaths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_file_durations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bad_channel_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Load data if mode is specified</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detect_and_load_data</span><span class="p">(</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">cache_policy</span><span class="o">=</span><span class="n">cache_policy</span><span class="p">,</span>
                <span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span><span class="p">,</span>
                <span class="n">extract_func</span><span class="o">=</span><span class="n">extract_func</span><span class="p">,</span>
                <span class="n">input_type</span><span class="o">=</span><span class="n">input_type</span><span class="p">,</span>
                <span class="n">file_pattern</span><span class="o">=</span><span class="n">file_pattern</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.detect_and_load_data">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.detect_and_load_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">detect_and_load_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;bin&quot;</span><span class="p">,</span> <span class="s2">&quot;si&quot;</span><span class="p">,</span> <span class="s2">&quot;mne&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bin&quot;</span><span class="p">,</span>
        <span class="n">cache_policy</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="s2">&quot;force_regenerate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">,</span>
        <span class="n">extract_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;si.BaseRecording&quot;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">input_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;folder&quot;</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;folder&quot;</span><span class="p">,</span>
        <span class="n">file_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load in recording based on mode.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;bin&quot;</span><span class="p">:</span>
            <span class="c1"># Binary file pipeline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convert_colbins_rowbins_to_rec</span><span class="p">(</span>
                <span class="n">cache_policy</span><span class="o">=</span><span class="n">cache_policy</span><span class="p">,</span>
                <span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;si&quot;</span><span class="p">:</span>
            <span class="c1"># EDF file pipeline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convert_file_with_si_to_recording</span><span class="p">(</span>
                <span class="n">extract_func</span><span class="o">=</span><span class="n">extract_func</span><span class="p">,</span>
                <span class="n">input_type</span><span class="o">=</span><span class="n">input_type</span><span class="p">,</span>
                <span class="n">file_pattern</span><span class="o">=</span><span class="n">file_pattern</span><span class="p">,</span>
                <span class="n">cache_policy</span><span class="o">=</span><span class="n">cache_policy</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;mne&quot;</span><span class="p">:</span>
            <span class="c1"># MNE file pipeline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convert_file_with_mne_to_recording</span><span class="p">(</span>
                <span class="n">extract_func</span><span class="o">=</span><span class="n">extract_func</span><span class="p">,</span>
                <span class="n">input_type</span><span class="o">=</span><span class="n">input_type</span><span class="p">,</span>
                <span class="n">file_pattern</span><span class="o">=</span><span class="n">file_pattern</span><span class="p">,</span>
                <span class="n">cache_policy</span><span class="o">=</span><span class="n">cache_policy</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.prepare_colbins_rowbins_metas">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.prepare_colbins_rowbins_metas">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_colbins_rowbins_metas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colbin_folder_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rowbin_folder_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__update_colbins_rowbins_metas</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_colbins_rowbins_metas_folders_exist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_colbins_rowbins_metas_not_empty</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">DDFBinaryMetadata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">DDFBinaryMetadata</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_metadata_consistency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metadata_objects</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">channel_names</span>

        <span class="c1"># Initialize file_end_datetimes from CSV metadata (will be overridden later if manual times provided)</span>
        <span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">dt_end</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_objects</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">file_end_datetimes</span><span class="p">):</span>
            <span class="c1"># If no CSV times available, manual times will be required later</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="n">file_end_datetimes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="n">file_end_datetimes</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;CSV metadata timestamps: </span><span class="si">{</span><span class="nb">len</span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">file_end_datetimes</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="p">])</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">file_end_datetimes</span><span class="p">)</span><span class="si">}</span><span class="s2"> files have timestamps&quot;</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_truncate_file_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]],</span> <span class="n">ref_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unified method to truncate any list of files.</span>

<span class="sd">        Args:</span>
<span class="sd">            files: List of files to truncate</span>
<span class="sd">            ref_list: Optional list of files to maintain relationships between. Only stems will be compared.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_truncate</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">files</span>

            <span class="c1"># Sort and truncate primary files</span>
            <span class="n">truncated</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">files</span><span class="p">)[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_truncate</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">truncated</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get a subset of files that match with ref_list</span>
            <span class="n">ref_list_stems</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_file_stem</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ref_list</span><span class="p">]</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">get_file_stem</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ref_list_stems</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">files</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__update_colbins_rowbins_metas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbin_folder_path</span> <span class="o">/</span> <span class="s2">&quot;*_ColMajor.bin&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbin_folder_path</span> <span class="o">/</span> <span class="s2">&quot;*_RowMajor.npy.gz&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbin_folder_path</span> <span class="o">/</span> <span class="s2">&quot;*_Meta.csv&quot;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">filepath_to_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">filepath_to_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">filepath_to_index</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Before prune: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> colbins, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> rowbins, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">)</span><span class="si">}</span><span class="s2"> metas&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__prune_empty_files</span><span class="p">()</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After prune: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> colbins, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> rowbins, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">)</span><span class="si">}</span><span class="s2"> metas&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Number of column-major and metadata files do not match&quot;</span><span class="p">)</span>

        <span class="n">metadatas</span> <span class="o">=</span> <span class="p">[</span><span class="n">DDFBinaryMetadata</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">metadatas</span><span class="p">:</span>
            <span class="c1"># if metadata file is empty, remove it and the corresponding column-major and row-major files</span>
            <span class="k">if</span> <span class="n">meta</span><span class="o">.</span><span class="n">metadata_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">searchstr</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">metadata_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_Meta&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span> <span class="k">if</span> <span class="n">searchstr</span> <span class="o">+</span> <span class="s2">&quot;_ColMajor.bin&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="k">if</span> <span class="n">searchstr</span> <span class="o">+</span> <span class="s2">&quot;_RowMajor.npy.gz&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="k">if</span> <span class="n">searchstr</span> <span class="o">+</span> <span class="s2">&quot;_Meta.csv&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

        <span class="c1"># if truncate is True, truncate the lists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_file_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_file_list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">,</span> <span class="n">ref_list</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_ColMajor.bin&quot;</span><span class="p">,</span> <span class="s2">&quot;_RowMajor.npy.gz&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_file_list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">,</span> <span class="n">ref_list</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_ColMajor.bin&quot;</span><span class="p">,</span> <span class="s2">&quot;_Meta.csv&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__prune_empty_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if the column-major file is empty, remove the corresponding row-major and metadata files</span>
        <span class="n">colbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">colbins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_ColMajor.bin&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="k">if</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_RowMajor.npy.gz&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="k">if</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_Meta.csv&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
        <span class="c1"># remove None values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metas</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__check_colbins_rowbins_metas_folders_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">colbin_folder_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column-major binary files folder not found: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colbin_folder_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowbin_folder_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Row-major binary files folder not found: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbin_folder_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata files folder not found: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__check_colbins_rowbins_metas_not_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No column-major binary files found&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No row-major binary files found. Convert with convert_colbins_to_rowbins()&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metas</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No metadata files found&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_metadata_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadatas</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DDFBinaryMetadata</span><span class="p">]):</span>
        <span class="n">meta0</span> <span class="o">=</span> <span class="n">metadatas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># attributes = [&#39;f_s&#39;, &#39;n_channels&#39;, &#39;precision&#39;, &#39;V_units&#39;, &#39;channel_names&#39;]</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_channels&quot;</span><span class="p">,</span> <span class="s2">&quot;precision&quot;</span><span class="p">,</span> <span class="s2">&quot;V_units&quot;</span><span class="p">,</span> <span class="s2">&quot;channel_names&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">meta0</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">metadatas</span><span class="p">]):</span>
                <span class="n">unequal_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">metadatas</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">meta0</span><span class="p">,</span> <span class="n">attr</span><span class="p">)]</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Inconsistent </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> values across metadata files: </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">meta0</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">unequal_values</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata files inconsistent at attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LongRecordingOrganizer.convert_colbins_rowbins_to_rec">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.convert_colbins_rowbins_to_rec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_colbins_rowbins_to_rec</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">overwrite_rowbins</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">,</span>
        <span class="n">cache_policy</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="s2">&quot;force_regenerate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_colbins_rowbins_metas</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_colbins_to_rowbins</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite_rowbins</span><span class="p">,</span> <span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_rowbins_to_rec</span><span class="p">(</span><span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span><span class="p">,</span> <span class="n">cache_policy</span><span class="o">=</span><span class="n">cache_policy</span><span class="p">)</span>
        <span class="c1"># Now that file_durations are available, finalize timestamps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize_file_timestamps</span><span class="p">()</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.convert_colbins_to_rowbins">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.convert_colbins_to_rowbins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_colbins_to_rowbins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert column-major binary files to row-major binary files, and save them in the rowbin_folder_path.</span>

<span class="sd">        Args:</span>
<span class="sd">            overwrite (bool, optional): If True, overwrite existing row-major binary files. Defaults to True.</span>
<span class="sd">            multiprocess_mode (Literal[&#39;dask&#39;, &#39;serial&#39;], optional): If &#39;dask&#39;, use dask to convert the files in parallel.</span>
<span class="sd">                If &#39;serial&#39;, convert the files in serial. Defaults to &#39;serial&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if overwrite, regenerate regardless of existence</span>
        <span class="c1"># else, read them (they exist) or make them (they don&#39;t exist)</span>
        <span class="c1"># there is no error condition, and rowbins will be recreated regardless of choice</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> column-major binary files to row-major format&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Overwrite flag set - regenerating all row-major files&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Overwrite flag not set - only generating missing row-major files&quot;</span><span class="p">)</span>

        <span class="n">delayed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">convert_colpath_to_rowpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbin_folder_path</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">aspath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span> <span class="ow">or</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">match</span> <span class="n">multiprocess_mode</span><span class="p">:</span>
                    <span class="k">case</span> <span class="s2">&quot;dask&quot;</span><span class="p">:</span>
                        <span class="n">delayed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">convert_ddfcolbin_to_ddfrowbin</span><span class="p">)(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">rowbin_folder_path</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="n">save_gzip</span><span class="o">=</span><span class="kc">True</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">case</span> <span class="s2">&quot;serial&quot;</span><span class="p">:</span>
                        <span class="n">convert_ddfcolbin_to_ddfrowbin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbin_folder_path</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="n">save_gzip</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid multiprocess_mode: </span><span class="si">{</span><span class="n">multiprocess_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multiprocess_mode</span> <span class="o">==</span> <span class="s2">&quot;dask&quot;</span><span class="p">:</span>
            <span class="c1"># Run all conversions in parallel</span>
            <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">delayed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__update_colbins_rowbins_metas</span><span class="p">()</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.convert_rowbins_to_rec">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.convert_rowbins_to_rec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_rowbins_to_rec</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">,</span>
        <span class="n">cache_policy</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="s2">&quot;force_regenerate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert row-major binary files to SpikeInterface Recording structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            multiprocess_mode (Literal[&#39;dask&#39;, &#39;serial&#39;], optional): If &#39;dask&#39;, use dask to convert the files in parallel.</span>
<span class="sd">                If &#39;serial&#39;, convert the files in serial. Defaults to &#39;serial&#39;.</span>
<span class="sd">            cache_policy (Literal): Caching policy for intermediate files (default: &quot;auto&quot;)</span>
<span class="sd">                - &quot;auto&quot;: Use cached files if exist and newer than sources, regenerate with logging if missing/invalid</span>
<span class="sd">                - &quot;always&quot;: Use cached files if exist, raise error if missing/invalid</span>
<span class="sd">                - &quot;force_regenerate&quot;: Always regenerate files, overwrite existing cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">si</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;SpikeInterface is required for convert_rowbins_to_rec&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> column-major files found, but only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> row-major files found. Some column-major files may be missing.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> row-major files found, but only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colbins</span><span class="p">)</span><span class="si">}</span><span class="s2"> column-major files found. Some row-major files will be ignored.&quot;</span>
            <span class="p">)</span>

        <span class="n">recs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t_cumulative</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temppaths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">match</span> <span class="n">multiprocess_mode</span><span class="p">:</span>
            <span class="k">case</span> <span class="s2">&quot;dask&quot;</span><span class="p">:</span>
                <span class="c1"># Compute all conversions in parallel</span>
                <span class="n">delayed_results</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">):</span>
                    <span class="n">delayed_results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">_convert_ddfrowbin_to_si_no_resample</span><span class="p">)(</span><span class="n">e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">)))</span>
                <span class="n">computed_results</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">delayed_results</span><span class="p">)</span>

                <span class="c1"># Reconstruct results in the correct order</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">computed_results</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.rowbins: </span><span class="si">{</span><span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">case</span> <span class="s2">&quot;serial&quot;</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">_convert_ddfrowbin_to_si_no_resample</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">]</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid multiprocess_mode: </span><span class="si">{</span><span class="n">multiprocess_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Process results</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">temppath</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temppaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temppath</span><span class="p">)</span>

            <span class="n">duration</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>

            <span class="n">t_cumulative</span> <span class="o">+=</span> <span class="n">duration</span>  <span class="c1"># NOTE  use numpy cumsum later</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumulative_file_durations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_cumulative</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">recs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No recordings generated. Check that all row-major files are present and readable.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowbins</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span><span class="si">}</span><span class="s2"> recordings generated. Some row-major files may be missing.&quot;</span><span class="p">)</span>

        <span class="c1"># Concatenate recordings first</span>
        <span class="n">concatenated_recording</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">concatenate_recordings</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span><span class="o">.</span><span class="n">rename_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)</span>

        <span class="c1"># Apply unified resampling to the concatenated recording</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="p">:</span> <span class="s2">&quot;si.BaseRecording&quot;</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_resampling</span><span class="p">(</span><span class="n">concatenated_recording</span><span class="p">)</span>

        <span class="c1"># Debug logging for critical recording features</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LongRecording created: </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.convert_file_with_si_to_recording">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.convert_file_with_si_to_recording">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_file_with_si_to_recording</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">extract_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;si.BaseRecording&quot;</span><span class="p">],</span>
        <span class="n">input_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;folder&quot;</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;folder&quot;</span><span class="p">,</span>
        <span class="n">file_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">cache_policy</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="s2">&quot;force_regenerate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a SpikeInterface Recording from a folder, a single file, or multiple files.</span>

<span class="sd">        This is a thin wrapper around ``extract_func`` that discovers inputs under</span>
<span class="sd">        ``self.base_folder_path`` and builds a ``si.BaseRecording`` accordingly.</span>

<span class="sd">        Modes:</span>

<span class="sd">        - ``folder``: Passes ``self.base_folder_path`` directly to ``extract_func``.</span>
<span class="sd">        - ``file``: Uses ``glob`` with ``file_pattern`` relative to ``self.base_folder_path``.</span>
<span class="sd">          If multiple matches are found, the first match is used and a warning is issued.</span>
<span class="sd">        - ``files``: Uses ``Path.glob`` with ``file_pattern`` under ``self.base_folder_path``,</span>
<span class="sd">          optionally truncates via ``self._truncate_file_list(...)``, sorts the files, applies</span>
<span class="sd">          ``extract_func`` to each file, and concatenates the resulting recordings via</span>
<span class="sd">          ``si.concatenate_recordings``.</span>

<span class="sd">        Args:</span>
<span class="sd">            extract_func (Callable[..., &quot;si.BaseRecording&quot;]): Function that consumes a path</span>
<span class="sd">                (folder or file path) and returns a ``si.BaseRecording``.</span>
<span class="sd">            input_type (Literal[&#39;folder&#39;, &#39;file&#39;, &#39;files&#39;], optional): How to discover inputs.</span>
<span class="sd">                Defaults to ``&#39;folder&#39;``.</span>
<span class="sd">            file_pattern (str, optional): Glob pattern used when ``input_type`` is ``&#39;file&#39;`` or</span>
<span class="sd">                ``&#39;files&#39;``. Defaults to ``&#39;*&#39;``.</span>
<span class="sd">            **kwargs: Additional keyword arguments forwarded to ``extract_func``.</span>

<span class="sd">        Side Effects:</span>
<span class="sd">            Sets ``self.LongRecording`` to the resulting recording and initializes ``self.meta``</span>
<span class="sd">            based on that recording&#39;s properties.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If no files are found for the given ``file_pattern`` or ``input_type`` is invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">si</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;SpikeInterface is required for convert_file_with_si_to_recording&quot;</span><span class="p">)</span>
        <span class="c1"># Early validation and file discovery</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;folder&quot;</span><span class="p">:</span>
            <span class="c1"># For single folder, validate that timestamps are provided</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_timestamps_for_mode</span><span class="p">(</span><span class="s2">&quot;si&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">datafolder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span>
            <span class="n">rec</span><span class="p">:</span> <span class="s2">&quot;si.BaseRecording&quot;</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafolder</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">n_processed_files</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
            <span class="c1"># For single file, validate that timestamps are provided</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_timestamps_for_mode</span><span class="p">(</span><span class="s2">&quot;si&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">datafiles</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span> <span class="o">/</span> <span class="n">file_pattern</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiple files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">. Using first file.&quot;</span><span class="p">)</span>
            <span class="n">datafile</span> <span class="o">=</span> <span class="n">datafiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rec</span><span class="p">:</span> <span class="s2">&quot;si.BaseRecording&quot;</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">n_processed_files</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;files&quot;</span><span class="p">:</span>
            <span class="n">datafiles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">file_pattern</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">datafiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_file_list</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span>
            <span class="c1"># Validate timestamps early before slow processing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_timestamps_for_mode</span><span class="p">(</span><span class="s2">&quot;si&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">))</span>
            <span class="n">datafiles</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># FIXME sort by index, or some other logic. Files may be out of order otherwise, messing up isday calculation</span>
            <span class="n">recs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;si.BaseRecording&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">extract_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">datafiles</span><span class="p">]</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">concatenate_recordings</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span>
            <span class="n">n_processed_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input_type: </span><span class="si">{</span><span class="n">input_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Store number of processed files for timestamp handling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span> <span class="o">=</span> <span class="n">n_processed_files</span>

        <span class="c1"># Apply unified resampling to the recording</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_resampling</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="c1"># For SI mode, don&#39;t use confusing DEFAULT_DAY if we have manual timestamps</span>
        <span class="n">dt_end</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># Will be set by finalize_file_timestamps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">DDFBinaryMetadata</span><span class="p">(</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">n_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_num_channels</span><span class="p">(),</span>
            <span class="n">f_s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">(),</span>
            <span class="n">dt_end</span><span class="o">=</span><span class="n">dt_end</span><span class="p">,</span>  <span class="c1"># Will be properly set by finalize_file_timestamps</span>
            <span class="n">channel_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_channel_ids</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>  <span class="c1"># NOTE may potentially be a list of integers, which is undesirable. The ability to set names is available in the extractor function itself</span>
            <span class="c1"># In the case this is integers, raise a warning and/or error, convert to string, and make a note that you may need to adjust parameters in si extractor</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">channel_names</span>

        <span class="c1"># For si mode, handle multiple files or single file</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;file_durations&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_n_processed_files&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Multiple files concatenated - estimate equal durations</span>
                <span class="n">total_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span>
                <span class="n">avg_duration</span> <span class="o">=</span> <span class="n">total_duration</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">avg_duration</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Single file or folder</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Apply manual timestamps if provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize_file_timestamps</span><span class="p">()</span>

        <span class="c1"># Debug logging for critical recording features</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LongRecording created via SI: </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_load_and_process_mne_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">extract_func</span><span class="p">,</span> <span class="n">input_type</span><span class="p">,</span> <span class="n">datafolder</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">datafiles</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">metadata_to_update</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method to load and process MNE data from various input types.&quot;&quot;&quot;</span>
        <span class="c1"># Load data based on input type</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;folder&quot;</span><span class="p">:</span>
            <span class="n">raw</span><span class="p">:</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafolder</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
            <span class="n">raw</span><span class="p">:</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;files&quot;</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running extract_func on </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> files&quot;</span><span class="p">)</span>
            <span class="n">raws</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">extract_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">datafiles</span><span class="p">]</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Concatenating </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">raws</span><span class="p">)</span><span class="si">}</span><span class="s2"> raws&quot;</span><span class="p">)</span>
            <span class="n">raw</span><span class="p">:</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">concatenate_raws</span><span class="p">(</span><span class="n">raws</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">raws</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input_type: </span><span class="si">{</span><span class="n">input_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;raw.info: </span><span class="si">{</span><span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Use user-specified n_jobs for MNE resampling, or default to 1</span>
        <span class="n">effective_n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span> <span class="k">if</span> <span class="n">n_jobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Using n_jobs=</span><span class="si">{</span><span class="n">effective_n_jobs</span><span class="si">}</span><span class="s2"> for MNE resampling (method param: </span><span class="si">{</span><span class="n">n_jobs</span><span class="si">}</span><span class="s2">, instance: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Ensure data is preloaded for parallel processing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preloading data&quot;</span><span class="p">)</span>
            <span class="n">raw</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>

        <span class="c1"># Use optimal resampling method with power-of-2 padding for speed</span>
        <span class="n">original_sfreq</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">original_sfreq</span> <span class="o">!=</span> <span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resampling from </span><span class="si">{</span><span class="n">original_sfreq</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">effective_n_jobs</span><span class="p">,</span> <span class="n">npad</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fft&quot;</span><span class="p">)</span>

            <span class="c1"># Update metadata to reflect the new sampling rate</span>
            <span class="k">if</span> <span class="n">metadata_to_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata_to_update</span><span class="o">.</span><span class="n">update_sampling_rate</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sampling frequency already matches </span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span><span class="si">}</span><span class="s2"> Hz, no resampling needed&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">raw</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_mne_data_no_resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">extract_func</span><span class="p">,</span> <span class="n">input_type</span><span class="p">,</span> <span class="n">datafolder</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">datafiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load MNE data without resampling for unified resampling pipeline.</span>

<span class="sd">        This method loads and concatenates MNE data but skips resampling,</span>
<span class="sd">        allowing the unified resampling to be applied after intermediate file creation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load data based on input type</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;folder&quot;</span><span class="p">:</span>
            <span class="n">raw</span><span class="p">:</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafolder</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
            <span class="n">raw</span><span class="p">:</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;files&quot;</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running extract_func on </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> files&quot;</span><span class="p">)</span>
            <span class="n">raws</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">extract_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">datafiles</span><span class="p">]</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Concatenating </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">raws</span><span class="p">)</span><span class="si">}</span><span class="s2"> raws&quot;</span><span class="p">)</span>
            <span class="n">raw</span><span class="p">:</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">concatenate_raws</span><span class="p">(</span><span class="n">raws</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">raws</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input_type: </span><span class="si">{</span><span class="n">input_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;raw.info: </span><span class="si">{</span><span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure data is preloaded</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preloading data&quot;</span><span class="p">)</span>
            <span class="n">raw</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>

        <span class="c1"># NOTE: No resampling applied here - will be handled by unified resampling after loading from cache</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Data loaded at original sampling rate (</span><span class="si">{</span><span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> Hz) - resampling will be applied later&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">raw</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_or_create_intermediate_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fname</span><span class="p">,</span>
        <span class="n">source_paths</span><span class="p">,</span>
        <span class="n">cache_policy</span><span class="p">,</span>
        <span class="n">intermediate</span><span class="p">,</span>
        <span class="n">extract_func</span><span class="p">,</span>
        <span class="n">input_type</span><span class="p">,</span>
        <span class="n">datafolder</span><span class="p">,</span>
        <span class="n">datafile</span><span class="p">,</span>
        <span class="n">datafiles</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get cached intermediate file or create it if needed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: (recording, raw_object, metadata) where:</span>
<span class="sd">                - recording: SpikeInterface recording object</span>
<span class="sd">                - raw_object: MNE Raw object (None if using cache)</span>
<span class="sd">                - metadata: DDFBinaryMetadata object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define metadata sidecar file path</span>
        <span class="n">meta_fname</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="n">fname</span><span class="o">.</span><span class="n">suffix</span> <span class="o">+</span> <span class="s2">&quot;.meta.json&quot;</span><span class="p">)</span>

        <span class="c1"># Check cache policy and validate cache files</span>
        <span class="k">if</span> <span class="n">cache_policy</span> <span class="o">==</span> <span class="s2">&quot;force_regenerate&quot;</span><span class="p">:</span>
            <span class="n">use_cache</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">get_cache_status_message</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cache policy &#39;force_regenerate&#39;: ignoring any existing cache&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check if both data and metadata cache files exist and are valid</span>
            <span class="n">data_cache_valid</span> <span class="o">=</span> <span class="n">should_use_cache_unified</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">source_paths</span><span class="p">,</span> <span class="n">cache_policy</span><span class="p">)</span>
            <span class="n">meta_cache_valid</span> <span class="o">=</span> <span class="n">meta_fname</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span> <span class="k">if</span> <span class="n">data_cache_valid</span> <span class="k">else</span> <span class="kc">False</span>

            <span class="c1"># Handle cache validation based on policy</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data_cache_valid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">meta_cache_valid</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cache_policy</span> <span class="o">==</span> <span class="s2">&quot;always&quot;</span><span class="p">:</span>
                    <span class="c1"># &#39;always&#39; policy: raise error if cache missing/invalid</span>
                    <span class="n">missing_files</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">data_cache_valid</span><span class="p">:</span>
                        <span class="n">missing_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;intermediate file (</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">meta_cache_valid</span><span class="p">:</span>
                        <span class="n">missing_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;metadata sidecar (</span><span class="si">{</span><span class="n">meta_fname</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cache policy &#39;always&#39; requires existing cache files, but missing: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_files</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">cache_policy</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                    <span class="c1"># &#39;auto&#39; policy: log and regenerate if cache missing/invalid</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">data_cache_valid</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Intermediate file </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> missing or outdated, regenerating&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">meta_cache_valid</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata sidecar </span><span class="si">{</span><span class="n">meta_fname</span><span class="si">}</span><span class="s2"> missing, regenerating&quot;</span><span class="p">)</span>
                    <span class="n">use_cache</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">use_cache</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_cache</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">use_cache</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">get_cache_status_message</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading cached metadata from </span><span class="si">{</span><span class="n">meta_fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Load metadata from sidecar file</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">DDFBinaryMetadata</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">meta_fname</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded cached metadata: </span><span class="si">{</span><span class="n">metadata</span><span class="o">.</span><span class="n">n_channels</span><span class="si">}</span><span class="s2"> channels, </span><span class="si">{</span><span class="n">metadata</span><span class="o">.</span><span class="n">f_s</span><span class="si">}</span><span class="s2"> Hz&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cache_policy</span> <span class="o">==</span> <span class="s2">&quot;always&quot;</span><span class="p">:</span>
                        <span class="c1"># &#39;always&#39; policy: raise error if metadata invalid</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Cache policy &#39;always&#39; requires valid metadata, but failed to load </span><span class="si">{</span><span class="n">meta_fname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="k">raise</span>
                    <span class="k">elif</span> <span class="n">cache_policy</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                        <span class="c1"># &#39;auto&#39; policy: log and regenerate if metadata invalid</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to load cached metadata from </span><span class="si">{</span><span class="n">meta_fname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Regenerating intermediate files due to invalid metadata&quot;</span><span class="p">)</span>
                        <span class="n">use_cache</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">use_cache</span><span class="p">:</span>
            <span class="c1"># Load cached data file</span>
            <span class="k">if</span> <span class="n">intermediate</span> <span class="o">==</span> <span class="s2">&quot;edf&quot;</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading cached edf file&quot;</span><span class="p">)</span>
                <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_edf</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">rec</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span>  <span class="c1"># No raw object when using cache</span>

            <span class="k">elif</span> <span class="n">intermediate</span> <span class="o">==</span> <span class="s2">&quot;bin&quot;</span><span class="p">:</span>
                <span class="c1"># Use metadata to reconstruct SpikeInterface parameters</span>
                <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;sampling_frequency&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">f_s</span><span class="p">,</span>
                    <span class="s2">&quot;num_channels&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
                    <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float64&quot;</span><span class="p">,</span>  <span class="c1"># We standardize on float64 for cached binary files</span>
                    <span class="s2">&quot;gain_to_uV&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;offset_to_uV&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;time_axis&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;is_filtered&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="p">}</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading from cached binary file </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_binary</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">rec</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span>  <span class="c1"># No raw object when using cache</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Generate new intermediate files</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">get_cache_status_message</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

            <span class="c1"># Create metadata object from raw info BEFORE resampling</span>
            <span class="c1"># We need to load one file to get the original metadata</span>
            <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;folder&quot;</span><span class="p">:</span>
                <span class="n">sample_raw</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafolder</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
                <span class="n">sample_raw</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;files&quot;</span><span class="p">:</span>
                <span class="n">sample_raw</span> <span class="o">=</span> <span class="n">extract_func</span><span class="p">(</span><span class="n">datafiles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input_type: </span><span class="si">{</span><span class="n">input_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Create metadata from the original raw object (before resampling)</span>
            <span class="n">original_info</span> <span class="o">=</span> <span class="n">sample_raw</span><span class="o">.</span><span class="n">info</span>

            <span class="c1"># Extract unit information from MNE Raw object</span>
            <span class="n">unit_str</span><span class="p">,</span> <span class="n">mult_to_uv</span> <span class="o">=</span> <span class="n">extract_mne_unit_info</span><span class="p">(</span><span class="n">original_info</span><span class="p">)</span>

            <span class="n">metadata</span> <span class="o">=</span> <span class="n">DDFBinaryMetadata</span><span class="p">(</span>
                <span class="n">metadata_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">n_channels</span><span class="o">=</span><span class="n">original_info</span><span class="p">[</span><span class="s2">&quot;nchan&quot;</span><span class="p">],</span>
                <span class="n">f_s</span><span class="o">=</span><span class="n">original_info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">],</span>  <span class="c1"># Original sampling rate</span>
                <span class="n">dt_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Will be set later by finalize_file_timestamps</span>
                <span class="n">channel_names</span><span class="o">=</span><span class="n">original_info</span><span class="p">[</span><span class="s2">&quot;ch_names&quot;</span><span class="p">],</span>
                <span class="n">V_units</span><span class="o">=</span><span class="n">unit_str</span><span class="p">,</span>
                <span class="n">mult_to_uV</span><span class="o">=</span><span class="n">mult_to_uv</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created metadata from raw: </span><span class="si">{</span><span class="n">metadata</span><span class="o">.</span><span class="n">n_channels</span><span class="si">}</span><span class="s2"> channels, </span><span class="si">{</span><span class="n">metadata</span><span class="o">.</span><span class="n">f_s</span><span class="si">}</span><span class="s2"> Hz&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit_str</span> <span class="ow">and</span> <span class="n">mult_to_uv</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted unit information: </span><span class="si">{</span><span class="n">unit_str</span><span class="si">}</span><span class="s2"> (mult_to_uV = </span><span class="si">{</span><span class="n">mult_to_uv</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No unit information could be extracted from MNE Raw object&quot;</span><span class="p">)</span>

            <span class="c1"># Load data without resampling (resampling will be applied after intermediate file loading)</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_mne_data_no_resample</span><span class="p">(</span><span class="n">extract_func</span><span class="p">,</span> <span class="n">input_type</span><span class="p">,</span> <span class="n">datafolder</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">datafiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Create the intermediate file</span>
            <span class="k">if</span> <span class="n">intermediate</span> <span class="o">==</span> <span class="s2">&quot;edf&quot;</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exporting raw to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">mne</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">export_raw</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;edf&quot;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading edf file&quot;</span><span class="p">)</span>
                <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_edf</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">intermediate</span> <span class="o">==</span> <span class="s2">&quot;bin&quot;</span><span class="p">:</span>
                <span class="c1"># Get raw info for SpikeInterface parameters</span>
                <span class="n">raw_info</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">info</span>
                <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;sampling_frequency&quot;</span><span class="p">:</span> <span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;num_channels&quot;</span><span class="p">:</span> <span class="n">raw_info</span><span class="p">[</span><span class="s2">&quot;nchan&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;gain_to_uV&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;offset_to_uV&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;time_axis&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;is_filtered&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="p">}</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exporting raw to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>  <span class="c1"># (n channels, n samples)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># (n samples, n channels)</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Writing to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading from </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">rec</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">read_binary</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid intermediate: </span><span class="si">{</span><span class="n">intermediate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Save metadata sidecar file</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving metadata to </span><span class="si">{</span><span class="n">meta_fname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">metadata</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">meta_fname</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">rec</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">metadata</span>

<div class="viewcode-block" id="LongRecordingOrganizer.convert_file_with_mne_to_recording">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.convert_file_with_mne_to_recording">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_file_with_mne_to_recording</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">extract_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Raw</span><span class="p">],</span>
        <span class="n">input_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;folder&quot;</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;folder&quot;</span><span class="p">,</span>
        <span class="n">file_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">intermediate</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;edf&quot;</span><span class="p">,</span> <span class="s2">&quot;bin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;edf&quot;</span><span class="p">,</span>
        <span class="n">intermediate_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_policy</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="s2">&quot;force_regenerate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert MNE-compatible files to SpikeInterface recording format with metadata caching.</span>

<span class="sd">        Args:</span>
<span class="sd">            extract_func (Callable): Function that takes a file path and returns mne.io.Raw object</span>
<span class="sd">            input_type (Literal): Type of input - &quot;folder&quot;, &quot;file&quot;, or &quot;files&quot;</span>
<span class="sd">            file_pattern (str): Glob pattern for file matching (default: &quot;*&quot;)</span>
<span class="sd">            intermediate (Literal): Intermediate format - &quot;edf&quot; or &quot;bin&quot; (default: &quot;edf&quot;)</span>
<span class="sd">            intermediate_name (str, optional): Custom name for intermediate file</span>
<span class="sd">            cache_policy (Literal): Caching policy for intermediate and metadata files (default: &quot;auto&quot;)</span>
<span class="sd">                - &quot;auto&quot;: Use cached files if both data and metadata exist and cache is newer than sources, regenerate with logging if missing/invalid</span>
<span class="sd">                - &quot;always&quot;: Use cached files if both data and metadata exist, raise error if missing/invalid</span>
<span class="sd">                - &quot;force_regenerate&quot;: Always regenerate files, overwrite existing cache</span>
<span class="sd">            multiprocess_mode (Literal): Processing mode - &quot;dask&quot; or &quot;serial&quot; (default: &quot;serial&quot;)</span>
<span class="sd">            n_jobs (int, optional): Number of jobs for MNE resampling. If None (default),</span>
<span class="sd">                                uses the instance n_jobs value. Set to -1 for automatic parallel</span>
<span class="sd">                                detection, or &gt;1 for specific job count.</span>
<span class="sd">            **kwargs: Additional arguments passed to extract_func</span>

<span class="sd">        Note:</span>
<span class="sd">            Creates two cache files: data file (e.g., file.edf) and metadata sidecar (e.g., file.edf.meta.json).</span>
<span class="sd">            Both files must exist for cache to be used. Metadata preserves channel names, original</span>
<span class="sd">            sampling rates, and other DDFBinaryMetadata fields across cache hits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">se</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;SpikeInterface is required for convert_file_with_mne_to_recording&quot;</span><span class="p">)</span>
        <span class="c1"># Early validation and file discovery</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;folder&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_timestamps_for_mode</span><span class="p">(</span><span class="s2">&quot;mne&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">datafolder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span>
            <span class="n">datafile</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">datafiles</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">source_paths</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span><span class="p">]</span>
            <span class="n">n_processed_files</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_timestamps_for_mode</span><span class="p">(</span><span class="s2">&quot;mne&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">datafiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">file_pattern</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiple files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">. Using first file.&quot;</span><span class="p">)</span>
            <span class="n">datafile</span> <span class="o">=</span> <span class="n">datafiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">datafolder</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">source_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">datafile</span><span class="p">]</span>
            <span class="n">n_processed_files</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;files&quot;</span><span class="p">:</span>
            <span class="n">datafiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">file_pattern</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No files found matching pattern: </span><span class="si">{</span><span class="n">file_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">datafiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_file_list</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_timestamps_for_mode</span><span class="p">(</span><span class="s2">&quot;mne&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">))</span>
            <span class="n">datafiles</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">datafolder</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">datafile</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">source_paths</span> <span class="o">=</span> <span class="n">datafiles</span>
            <span class="n">n_processed_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">datafiles</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input_type: </span><span class="si">{</span><span class="n">input_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Store number of processed files for timestamp handling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span> <span class="o">=</span> <span class="n">n_processed_files</span>

        <span class="c1"># Determine intermediate file path</span>
        <span class="n">intermediate_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_mne-to-rec&quot;</span> <span class="k">if</span> <span class="n">intermediate_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">intermediate_name</span>
        <span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">intermediate_name</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">intermediate</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Get or create the intermediate file (this handles caching logic)</span>
        <span class="n">rec</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_intermediate_file</span><span class="p">(</span>
            <span class="n">fname</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span>
            <span class="n">source_paths</span><span class="o">=</span><span class="n">source_paths</span><span class="p">,</span>
            <span class="n">cache_policy</span><span class="o">=</span><span class="n">cache_policy</span><span class="p">,</span>
            <span class="n">intermediate</span><span class="o">=</span><span class="n">intermediate</span><span class="p">,</span>
            <span class="n">extract_func</span><span class="o">=</span><span class="n">extract_func</span><span class="p">,</span>
            <span class="n">input_type</span><span class="o">=</span><span class="n">input_type</span><span class="p">,</span>
            <span class="n">datafolder</span><span class="o">=</span><span class="n">datafolder</span><span class="p">,</span>
            <span class="n">datafile</span><span class="o">=</span><span class="n">datafile</span><span class="p">,</span>
            <span class="n">datafiles</span><span class="o">=</span><span class="n">datafiles</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Set metadata first so resampling can update it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">metadata</span>

        <span class="c1"># Apply unified resampling to the loaded recording (this will update metadata sampling rate)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_resampling</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="c1"># Update dt_end for manual timestamps (will be properly set by finalize_file_timestamps)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">dt_end</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Will be set by finalize_file_timestamps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">channel_names</span>

        <span class="c1"># For mne mode, handle multiple files or single file</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;file_durations&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_n_processed_files&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Multiple files concatenated - estimate equal durations</span>
                <span class="n">total_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span>
                <span class="n">avg_duration</span> <span class="o">=</span> <span class="n">total_duration</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">avg_duration</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_processed_files</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Single file or folder</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Apply manual timestamps if provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize_file_timestamps</span><span class="p">()</span>

        <span class="c1"># Debug logging for critical recording features</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LongRecording created via MNE: </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.cleanup_rec">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.cleanup_rec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cleanup_rec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;LongRecording does not exist, probably deleted already&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tpath</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">temppaths</span><span class="p">:</span>
            <span class="n">Path</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">tpath</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.get_num_fragments">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.get_num_fragments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment_len_s</span><span class="p">):</span>
        <span class="n">frag_len_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__time_to_idx</span><span class="p">(</span><span class="n">fragment_len_s</span><span class="p">)</span>
        <span class="n">duration_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_num_frames</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">duration_idx</span> <span class="o">/</span> <span class="n">frag_len_idx</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__time_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_s</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">time_to_sample_index</span><span class="p">(</span><span class="n">time_s</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__idx_to_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">sample_index_to_time</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

<div class="viewcode-block" id="LongRecordingOrganizer.get_fragment">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.get_fragment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment_len_s</span><span class="p">,</span> <span class="n">fragment_idx</span><span class="p">):</span>
        <span class="n">startidx</span><span class="p">,</span> <span class="n">endidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fragidx_to_startendind</span><span class="p">(</span><span class="n">fragment_len_s</span><span class="p">,</span> <span class="n">fragment_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">frame_slice</span><span class="p">(</span><span class="n">startidx</span><span class="p">,</span> <span class="n">endidx</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.get_dur_fragment">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.get_dur_fragment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dur_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment_len_s</span><span class="p">,</span> <span class="n">fragment_idx</span><span class="p">):</span>
        <span class="n">startidx</span><span class="p">,</span> <span class="n">endidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fragidx_to_startendind</span><span class="p">(</span><span class="n">fragment_len_s</span><span class="p">,</span> <span class="n">fragment_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__idx_to_time</span><span class="p">(</span><span class="n">endidx</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__idx_to_time</span><span class="p">(</span><span class="n">startidx</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.get_datetime_fragment">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.get_datetime_fragment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_datetime_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment_len_s</span><span class="p">,</span> <span class="n">fragment_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the datetime for a specific fragment using the timestamp mapper.</span>

<span class="sd">        Args:</span>
<span class="sd">            fragment_len_s (float): Length of each fragment in seconds</span>
<span class="sd">            fragment_idx (int): Index of the fragment to get datetime for</span>

<span class="sd">        Returns:</span>
<span class="sd">            datetime: The datetime corresponding to the start of the fragment</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If timestamp mapper is not initialized (only available in &#39;bin&#39; mode)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimestampMapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="p">)</span><span class="o">.</span><span class="n">get_fragment_timestamp</span><span class="p">(</span>
            <span class="n">fragment_idx</span><span class="p">,</span> <span class="n">fragment_len_s</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__fragidx_to_startendind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fragment_len_s</span><span class="p">,</span> <span class="n">fragment_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert fragment index to start and end sample indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            fragment_len_s (float): Length of each fragment in seconds</span>
<span class="sd">            fragment_idx (int): Index of the fragment to get indices for</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[int, int]: Start and end sample indices for the fragment. The end index is capped at the recording length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frag_len_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__time_to_idx</span><span class="p">(</span><span class="n">fragment_len_s</span><span class="p">)</span>
        <span class="n">startidx</span> <span class="o">=</span> <span class="n">frag_len_idx</span> <span class="o">*</span> <span class="n">fragment_idx</span>
        <span class="n">endidx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frag_len_idx</span> <span class="o">*</span> <span class="p">(</span><span class="n">fragment_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_num_frames</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">startidx</span><span class="p">,</span> <span class="n">endidx</span>

<div class="viewcode-block" id="LongRecordingOrganizer.convert_to_mne">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.convert_to_mne">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_to_mne</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert this LongRecording object to an MNE RawArray.</span>

<span class="sd">        Returns:</span>
<span class="sd">            mne.io.RawArray: The converted MNE RawArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_traces</span><span class="p">(</span><span class="n">return_scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># This gets data in (n_samples, n_channels) format</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Convert to (n_channels, n_samples) format for MNE</span>

        <span class="n">info</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">create_info</span><span class="p">(</span>
            <span class="n">ch_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">(),</span> <span class="n">ch_types</span><span class="o">=</span><span class="s2">&quot;eeg&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.compute_bad_channels">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.compute_bad_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_bad_channels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lof_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">limit_memory</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">force_recompute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute bad channels using LOF analysis with unified score storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            lof_threshold (float, optional): Threshold for determining bad channels from LOF scores.</span>
<span class="sd">                                           If None, only computes/loads scores without setting bad_channel_names.</span>
<span class="sd">            limit_memory (bool): Whether to reduce memory usage by decimation and float16.</span>
<span class="sd">            force_recompute (bool): Whether to recompute LOF scores even if they exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if LOF scores already exist and are current</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_recompute</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;lof_scores&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using existing LOF scores&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute new LOF scores</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lof_scores</span><span class="p">(</span><span class="n">limit_memory</span><span class="o">=</span><span class="n">limit_memory</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores</span> <span class="o">=</span> <span class="n">scores</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computed LOF scores for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to compute LOF scores for recording: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="c1"># Apply threshold if provided</span>
        <span class="k">if</span> <span class="n">lof_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_lof_threshold</span><span class="p">(</span><span class="n">lof_threshold</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_lof_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_memory</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute raw LOF scores for all channels.</span>

<span class="sd">        Args:</span>
<span class="sd">            limit_memory (bool): Whether to reduce memory usage.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: LOF scores for each channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">Natural_Neighbor</span><span class="p">()</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing LOF scores for </span><span class="si">{</span><span class="n">rec</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rec_np</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">get_traces</span><span class="p">(</span><span class="n">return_scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># (n_samples, n_channels)</span>

            <span class="k">if</span> <span class="n">rec_np</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rec_np</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to get traces from recording - data is None or empty&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Recording traces are None or empty&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got recording shape: </span><span class="si">{</span><span class="n">rec_np</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">limit_memory</span><span class="p">:</span>
                <span class="n">rec_np</span> <span class="o">=</span> <span class="n">rec_np</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
                <span class="n">rec_np</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="n">rec_np</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decimated traces shape: </span><span class="si">{</span><span class="n">rec_np</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rec_np</span> <span class="o">=</span> <span class="n">rec_np</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># (n_channels, n_samples)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transposed traces shape: </span><span class="si">{</span><span class="n">rec_np</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Compute the optimal number of neighbors</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rec_np</span><span class="p">)</span>
            <span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">algorithm</span><span class="p">()</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computed n_neighbors for LOF computation: </span><span class="si">{</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Initialize LocalOutlierFactor</span>
            <span class="c1"># lof = LocalOutlierFactor(n_neighbors=n_neighbors, metric=&quot;minkowski&quot;, p=2)</span>
            <span class="c1"># distance_vector = pdist(rec_np, metric=&quot;seuclidean&quot;)</span>
            <span class="n">distance_vector</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">rec_np</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
            <span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">distance_vector</span><span class="p">)</span>
            <span class="n">lof</span> <span class="o">=</span> <span class="n">LocalOutlierFactor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">)</span>
            <span class="c1"># lof = LocalOutlierFactor(n_neighbors=n_neighbors, metric=pdist, )</span>

            <span class="c1"># Compute the outlier scores</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing outlier scores&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">nn</span>
            <span class="c1"># lof.fit(rec_np)</span>
            <span class="n">lof</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">rec_np</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">lof</span><span class="o">.</span><span class="n">negative_outlier_factor_</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LOF computation successful: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LOF scores: </span><span class="si">{</span><span class="n">scores</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">scores</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to compute LOF scores: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Recording info: channels=</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;channel_names&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;duration=</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;duration&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;rec&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">locals</span><span class="p">()</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;unknown&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span>

<div class="viewcode-block" id="LongRecordingOrganizer.apply_lof_threshold">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.apply_lof_threshold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_lof_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lof_threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply threshold to existing LOF scores to determine bad channels.</span>

<span class="sd">        Args:</span>
<span class="sd">            lof_threshold (float): Threshold for determining bad channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;lof_scores&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LOF scores not available. Run compute_bad_channels() first.&quot;</span><span class="p">)</span>

        <span class="n">is_inlier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores</span> <span class="o">&lt;</span> <span class="n">lof_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bad_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">is_inlier</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applied threshold </span><span class="si">{</span><span class="n">lof_threshold</span><span class="si">}</span><span class="s2">: bad_channel_names = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bad_channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.get_lof_scores">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.get_lof_scores">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_lof_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get LOF scores with channel names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary mapping channel names to LOF scores.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;lof_scores&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LOF scores not available. Run compute_bad_channels() first.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_manual_time_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that manual time parameters are correctly specified.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="p">(</span><span class="n">datetime</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;manual_datetimes must be a datetime object or list of datetime objects&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_timestamps_for_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">expected_n_files</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that manual timestamps are provided when required for specific modes.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode (str): The processing mode (&#39;si&#39;, &#39;mne&#39;, or &#39;bin&#39;)</span>
<span class="sd">            expected_n_files (int, optional): Expected number of files for validation</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If timestamps are required but not provided or if count mismatch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;si&quot;</span><span class="p">,</span> <span class="s2">&quot;mne&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;manual_datetimes must be provided for </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> mode when no CSV metadata is available&quot;</span><span class="p">)</span>

            <span class="c1"># If list provided and expected files known, validate length</span>
            <span class="k">if</span> <span class="n">expected_n_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_n_files</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;manual_datetimes length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">)</span><span class="si">}</span><span class="s2">) must match &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;number of input files (</span><span class="si">{</span><span class="n">expected_n_files</span><span class="si">}</span><span class="s2">) for </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> mode&quot;</span>
                    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_manual_file_datetimes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_files</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">durations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">datetime</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute file end datetimes based on manual time specifications.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_files (int): Number of files</span>
<span class="sd">            durations (list[float]): Duration of each file in seconds</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[datetime]: End datetime for each file</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If manual_datetimes length doesn&#39;t match number of files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># List of times provided - one per file</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_files</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;manual_datetimes length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">)</span><span class="si">}</span><span class="s2">) must match number of files (</span><span class="si">{</span><span class="n">n_files</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Convert start times to end times or vice versa</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datetimes_are_start</span><span class="p">:</span>
                <span class="c1"># Convert start times to end times</span>
                <span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">start_time</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">duration</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">duration</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use as end times directly</span>
                <span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span><span class="p">)</span>

            <span class="c1"># Check contiguity (warn instead of error)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_file_contiguity</span><span class="p">(</span><span class="n">file_end_datetimes</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">file_end_datetimes</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Single datetime provided - global start or end time</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datetimes_are_start</span><span class="p">:</span>
                <span class="c1"># Global start time - compute cumulative end times</span>
                <span class="n">current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span>
                <span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">duration</span> <span class="ow">in</span> <span class="n">durations</span><span class="p">:</span>
                    <span class="n">current_time</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">duration</span><span class="p">)</span>
                    <span class="n">file_end_datetimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">file_end_datetimes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Global end time - work backwards</span>
                <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manual_datetimes</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">total_duration</span><span class="p">)</span>
                <span class="n">current_time</span> <span class="o">=</span> <span class="n">start_time</span>
                <span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">duration</span> <span class="ow">in</span> <span class="n">durations</span><span class="p">:</span>
                    <span class="n">current_time</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">duration</span><span class="p">)</span>
                    <span class="n">file_end_datetimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">file_end_datetimes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_file_contiguity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_end_datetimes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">datetime</span><span class="p">],</span> <span class="n">durations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check that files are contiguous in time and warn if they&#39;re not.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_end_datetimes (list[datetime]): End datetime for each file</span>
<span class="sd">            durations (list[float]): Duration of each file in seconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_end_datetimes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># Single file or no files - nothing to check</span>

        <span class="n">tolerance_seconds</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Allow 1 second tolerance for rounding errors</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_end_datetimes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Start time of next file should equal end time of current file</span>
            <span class="n">current_end</span> <span class="o">=</span> <span class="n">file_end_datetimes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">next_start</span> <span class="o">=</span> <span class="n">file_end_datetimes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">durations</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">gap_seconds</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_start</span> <span class="o">-</span> <span class="n">current_end</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">gap_seconds</span> <span class="o">&gt;</span> <span class="n">tolerance_seconds</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Files may not be contiguous: gap of </span><span class="si">{</span><span class="n">gap_seconds</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s between &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;file </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (ends </span><span class="si">{</span><span class="n">current_end</span><span class="si">}</span><span class="s2">) and file </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> (starts </span><span class="si">{</span><span class="n">next_start</span><span class="si">}</span><span class="s2">). &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Tolerance is </span><span class="si">{</span><span class="n">tolerance_seconds</span><span class="si">}</span><span class="s2">s.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">gap_seconds</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">tolerance_seconds</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Files may overlap: negative gap of </span><span class="si">{</span><span class="n">gap_seconds</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s between &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;file </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (ends </span><span class="si">{</span><span class="n">current_end</span><span class="si">}</span><span class="s2">) and file </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> (starts </span><span class="si">{</span><span class="n">next_start</span><span class="si">}</span><span class="s2">). &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Tolerance is </span><span class="si">{</span><span class="n">tolerance_seconds</span><span class="si">}</span><span class="s2">s.&quot;</span>
                <span class="p">)</span>

<div class="viewcode-block" id="LongRecordingOrganizer.finalize_file_timestamps">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.finalize_file_timestamps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">finalize_file_timestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finalize file timestamps using manual times if provided, otherwise validate CSV times.&quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finalizing file timestamps&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;file_durations&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># No file durations available yet</span>

        <span class="n">manual_file_datetimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_manual_file_datetimes</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">manual_file_datetimes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="o">=</span> <span class="n">manual_file_datetimes</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using manual timestamps: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">manual_file_datetimes</span><span class="p">)</span><span class="si">}</span><span class="s2"> file end times specified&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check if CSV times are sufficient (only for bin mode)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;file_end_datetimes&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No dates found in any metadata object and no manual times specified!&quot;</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using CSV metadata timestamps&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For si/mne modes, manual timestamps are required</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;manual_datetimes must be provided when no CSV metadata is available!&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LongRecordingOrganizer.__str__">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of critical long recording features.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;LongRecordingOrganizer: No recording loaded yet&quot;</span>

        <span class="n">n_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_num_channels</span><span class="p">()</span>
        <span class="n">sampling_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">()</span>
        <span class="n">total_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span>

        <span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;file_durations&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_durations</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">timestamp_info</span> <span class="o">=</span> <span class="s2">&quot;No timestamps&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;file_end_datetimes&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">:</span>
            <span class="n">timestamp_coverage</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
            <span class="n">timestamp_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">timestamp_coverage</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">)</span><span class="si">}</span><span class="s2"> files have timestamps&quot;</span>

        <span class="n">channel_info</span> <span class="o">=</span> <span class="s2">&quot;No channels&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;channel_names&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">:</span>
            <span class="c1"># if len(self.channel_names) &lt;= 5:</span>
            <span class="n">channel_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="c1"># else:</span>
            <span class="c1">#     channel_info = f&quot;[{&#39;, &#39;.join(self.channel_names[:3])}, ..., {self.channel_names[-1]}] ({len(self.channel_names)} total)&quot;</span>

        <span class="n">metadata_info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;meta&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;precision&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">precision</span><span class="p">:</span>
                <span class="n">metadata_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">precision</span><span class="si">}</span><span class="s2"> precision&quot;</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;V_units&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">V_units</span><span class="p">:</span>
                <span class="n">metadata_info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">V_units</span><span class="si">}</span><span class="s2"> units&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;LongRecording: </span><span class="si">{</span><span class="n">n_files</span><span class="si">}</span><span class="s2"> files, </span><span class="si">{</span><span class="n">n_channels</span><span class="si">}</span><span class="s2"> channels, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sampling_freq</span><span class="si">}</span><span class="s2"> Hz, </span><span class="si">{</span><span class="n">total_duration</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s duration, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;channels: </span><span class="si">{</span><span class="n">channel_info</span><span class="si">}{</span><span class="n">metadata_info</span><span class="si">}</span><span class="s2">, timestamps: </span><span class="si">{</span><span class="n">timestamp_info</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_resampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recording</span><span class="p">:</span> <span class="s2">&quot;si.BaseRecording&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;si.BaseRecording&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply unified resampling using SpikeInterface preprocessing.</span>

<span class="sd">        This method centralizes all resampling logic across the different data loading pipelines</span>
<span class="sd">        (binary, MNE, SI) to use the fast SpikeInterface resampling implementation consistently.</span>

<span class="sd">        Args:</span>
<span class="sd">            recording (si.BaseRecording): The recording to resample</span>

<span class="sd">        Returns:</span>
<span class="sd">            si.BaseRecording: The resampled recording</span>

<span class="sd">        Raises:</span>
<span class="sd">            ImportError: If SpikeInterface preprocessing is not available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">spre</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;SpikeInterface preprocessing is required for resampling&quot;</span><span class="p">)</span>

        <span class="n">current_rate</span> <span class="o">=</span> <span class="n">recording</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">()</span>
        <span class="n">target_rate</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">GLOBAL_SAMPLING_RATE</span>

        <span class="k">if</span> <span class="n">current_rate</span> <span class="o">==</span> <span class="n">target_rate</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recording already at target sampling rate (</span><span class="si">{</span><span class="n">target_rate</span><span class="si">}</span><span class="s2"> Hz), no resampling needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">recording</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resampling recording from </span><span class="si">{</span><span class="n">current_rate</span><span class="si">}</span><span class="s2"> Hz to </span><span class="si">{</span><span class="n">target_rate</span><span class="si">}</span><span class="s2"> Hz using SpikeInterface&quot;</span><span class="p">)</span>

        <span class="c1"># Use SpikeInterface resampling with margin to reduce edge effects</span>
        <span class="n">resampled_recording</span> <span class="o">=</span> <span class="n">spre</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">recording</span><span class="o">=</span><span class="n">recording</span><span class="p">,</span>
            <span class="n">resample_rate</span><span class="o">=</span><span class="n">target_rate</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update metadata to reflect new sampling rate</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;meta&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update_sampling_rate</span><span class="p">(</span><span class="n">target_rate</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully resampled recording to </span><span class="si">{</span><span class="n">target_rate</span><span class="si">}</span><span class="s2"> Hz&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resampled_recording</span>

<div class="viewcode-block" id="LongRecordingOrganizer.merge">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.merge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_lro</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge another LRO into this one using si.concatenate_recordings.</span>

<span class="sd">        This creates a new concatenated recording from this LRO and the other LRO.</span>
<span class="sd">        The other LRO should represent a later time period to maintain temporal order.</span>

<span class="sd">        Args:</span>
<span class="sd">            other_lro (LongRecordingOrganizer): The LRO to merge into this one</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If LROs are incompatible (different channels, sampling rates, etc.)</span>
<span class="sd">            ImportError: If SpikeInterface is not available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">si</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;SpikeInterface is required for LRO merging&quot;</span><span class="p">)</span>

        <span class="c1"># Validate merge compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_merge_compatibility</span><span class="p">(</span><span class="n">other_lro</span><span class="p">)</span>

        <span class="c1"># Concatenate recordings using SpikeInterface</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Merging LRO </span><span class="si">{</span><span class="n">other_lro</span><span class="o">.</span><span class="n">base_folder_path</span><span class="si">}</span><span class="s2"> into </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">concatenate_recordings</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span><span class="p">,</span> <span class="n">other_lro</span><span class="o">.</span><span class="n">LongRecording</span><span class="p">])</span>

        <span class="c1"># Update metadata after merge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_metadata_after_merge</span><span class="p">(</span><span class="n">other_lro</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Successfully merged LRO recordings&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_merge_compatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_lro</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that two LROs can be safely merged.</span>

<span class="sd">        Args:</span>
<span class="sd">            other_lro (LongRecordingOrganizer): The LRO to validate against this one</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If LROs are incompatible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check channel names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">!=</span> <span class="n">other_lro</span><span class="o">.</span><span class="n">channel_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Channel names mismatch: this LRO has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">, other LRO has </span><span class="si">{</span><span class="n">other_lro</span><span class="o">.</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check sampling rates</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;f_s&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;f_s&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">f_s</span> <span class="o">!=</span> <span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">f_s</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Sampling rate mismatch: this LRO has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">f_s</span><span class="si">}</span><span class="s2"> Hz, other LRO has </span><span class="si">{</span><span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">f_s</span><span class="si">}</span><span class="s2"> Hz&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Check channel counts</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;n_channels&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;n_channels&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">n_channels</span> <span class="o">!=</span> <span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">n_channels</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Channel count mismatch: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;this LRO has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">n_channels</span><span class="si">}</span><span class="s2"> channels, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;other LRO has </span><span class="si">{</span><span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">n_channels</span><span class="si">}</span><span class="s2"> channels&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Check that both have valid recordings</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">LongRecording</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This LRO does not have a valid LongRecording&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other_lro</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">other_lro</span><span class="o">.</span><span class="n">LongRecording</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Other LRO does not have a valid LongRecording&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_metadata_after_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_lro</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update this LRO&#39;s metadata after merging with another LRO.</span>

<span class="sd">        Args:</span>
<span class="sd">            other_lro (LongRecordingOrganizer): The LRO that was merged into this one</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update end time to reflect the merged recording duration</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;dt_end&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="s2">&quot;dt_end&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">dt_end</span> <span class="o">=</span> <span class="n">other_lro</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">dt_end</span>

        <span class="c1"># Note: Channel names, sampling rate, etc. should already be validated as identical</span>

<div class="viewcode-block" id="LongRecordingOrganizer.__repr__">
<a class="viewcode-back" href="../../../api/core/long_recording_organizer.html#neurodent.core.LongRecordingOrganizer.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a detailed string representation for debugging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Joseph Dong, Yongtaek Oh, Eric Marsh.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>