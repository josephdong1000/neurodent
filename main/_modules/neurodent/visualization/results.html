
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>neurodent.visualization.results &#8212; Neurodent 0.2.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=938c9ccc"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/neurodent/visualization/results';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://josephdong1000.github.io/neurodent/_static/switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '0.2.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Neurodent</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation/index.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../quickstart/index.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API Reference
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../license/index.html">
    License
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/josephdong1000/neurodent" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/neurodent/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation/index.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../quickstart/index.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../license/index.html">
    License
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/josephdong1000/neurodent" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/neurodent/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">neurodent.visualization.results</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for neurodent.visualization.results</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dask</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dask.array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">da</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">mne</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">spikeinterface</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">si</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dask</span><span class="w"> </span><span class="kn">import</span> <span class="n">delayed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">django.utils.text</span><span class="w"> </span><span class="kn">import</span> <span class="n">slugify</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">zscore</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_opening</span><span class="p">,</span> <span class="n">binary_closing</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">..</span><span class="w"> </span><span class="kn">import</span> <span class="n">constants</span><span class="p">,</span> <span class="n">core</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">FragmentAnalyzer</span><span class="p">,</span> <span class="n">get_temp_directory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.analyze_sort</span><span class="w"> </span><span class="kn">import</span> <span class="n">MOUNTAINSORT_AVAILABLE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.frequency_domain_spike_detection</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencyDomainSpikeDetector</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">parse_chname_to_abbrev</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AnimalFeatureParser</span><span class="p">:</span>
    <span class="c1"># REVIEW make this a utility function and refactor across codebase?</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_average_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">colname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">weightsname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;duration&quot;</span><span class="p">):</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">weightsname</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">weightsname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">weightsname</span><span class="p">]</span>
        <span class="n">colitem</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">match</span> <span class="n">colname</span><span class="p">:</span>  <span class="c1"># NOTE refactor this to use constants</span>
            <span class="k">case</span> <span class="p">(</span>
                <span class="s2">&quot;rms&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;ampvar&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;psdtotal&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;pcorr&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;zpcorr&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;nspike&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;logrms&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;logampvar&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;logpsdtotal&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;lognspike&quot;</span>
                <span class="o">|</span> <span class="s2">&quot;psdslope&quot;</span>
            <span class="p">):</span>
                <span class="n">col_agg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">nanaverage</span><span class="p">(</span><span class="n">col_agg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

            <span class="k">case</span> <span class="s2">&quot;cohere&quot;</span> <span class="o">|</span> <span class="s2">&quot;zcohere&quot;</span> <span class="o">|</span> <span class="s2">&quot;imcoh&quot;</span> <span class="o">|</span> <span class="s2">&quot;zimcoh&quot;</span> <span class="o">|</span> <span class="s2">&quot;psdband&quot;</span> <span class="o">|</span> <span class="s2">&quot;psdfrac&quot;</span> <span class="o">|</span> <span class="s2">&quot;logpsdband&quot;</span> <span class="o">|</span> <span class="s2">&quot;logpsdfrac&quot;</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="n">colitem</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">column</span><span class="p">])</span>
                    <span class="n">avg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">nanaverage</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

            <span class="k">case</span> <span class="s2">&quot;psd&quot;</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">colitem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">column</span><span class="p">])</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">nanaverage</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">))</span>

            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized type in column </span><span class="si">{</span><span class="n">colname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">colitem</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">avg</span>


<div class="viewcode-block" id="AnimalOrganizer">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AnimalOrganizer</span><span class="p">(</span><span class="n">AnimalFeatureParser</span><span class="p">):</span>
<div class="viewcode-block" id="AnimalOrganizer.__init__">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base_folder_path</span><span class="p">,</span>
        <span class="n">anim_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">day_sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;nest&quot;</span><span class="p">,</span> <span class="s2">&quot;concat&quot;</span><span class="p">,</span> <span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="s2">&quot;noday&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;concat&quot;</span><span class="p">,</span>
        <span class="n">assume_from_number</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">skip_days</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">truncate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lro_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        AnimalOrganizer is used to organize data from a single animal into a format that can be used for analysis.</span>
<span class="sd">        It is used to organize data from a single animal into a format that can be used for analysis.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_folder_path (str): The path to the base folder of the animal data.</span>
<span class="sd">            anim_id (str): The ID of the animal. This should correspond to only one animal.</span>
<span class="sd">            day_sep (str, optional): Separator for day in folder name. Set to None or empty string to get all folders. Defaults to None.</span>
<span class="sd">            mode (Literal[&quot;nest&quot;, &quot;concat&quot;, &quot;base&quot;, &quot;noday&quot;], optional): The mode of the AnimalOrganizer. Defaults to &quot;concat&quot;.</span>
<span class="sd">                File structure patterns (where * indicates search location):</span>
<span class="sd">                &quot;nest&quot;: base_folder_path / animal_id / *date_format* (looks for folders/files within animal_id subdirectories)</span>
<span class="sd">                &quot;concat&quot;: base_folder_path / *animal_id*date_format* (looks for folders/files with animal_id+date in name at base level)</span>
<span class="sd">                &quot;base&quot;: base_folder_path / * (looks for folders/files directly in base_folder_path)</span>
<span class="sd">                &quot;noday&quot;: base_folder_path / *animal_id* (same as concat but expects single unique match, no date filtering)</span>
<span class="sd">            assume_from_number (bool, optional): Whether to assume the animal ID is a number. Defaults to False.</span>
<span class="sd">            skip_days (list[str], optional): The days to skip. Defaults to [].</span>
<span class="sd">            truncate (bool|int, optional): Whether to truncate the data. Defaults to False.</span>
<span class="sd">            lro_kwargs (dict, optional): Keyword arguments for LongRecordingOrganizer. Defaults to {}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">base_folder_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anim_id</span> <span class="o">=</span> <span class="n">anim_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animal_param</span> <span class="o">=</span> <span class="p">[</span><span class="n">anim_id</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">day_sep</span> <span class="o">=</span> <span class="n">day_sep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span> <span class="o">=</span> <span class="n">assume_from_number</span>

        <span class="k">match</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">case</span> <span class="s2">&quot;nest&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">anim_id</span><span class="si">}</span><span class="s2">*&quot;</span> <span class="o">/</span> <span class="s2">&quot;*&quot;</span>
            <span class="k">case</span> <span class="s2">&quot;concat&quot;</span> <span class="o">|</span> <span class="s2">&quot;noday&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">anim_id</span><span class="si">}</span><span class="s2">*&quot;</span>
                <span class="c1"># self.bin_folder_pat = self.base_folder_path / f&quot;*{self.anim_id}*{self.date_format}*&quot;</span>
            <span class="k">case</span> <span class="s2">&quot;base&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_folder_path</span>
            <span class="c1"># case &#39;noday&#39;:</span>
            <span class="c1">#     self.bin_folder_pat = self.base_folder_path / f&quot;*{self.anim_id}*&quot;</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_pattern</span><span class="p">))</span>

        <span class="c1"># Filter to only include directories (LongRecordingOrganizer expects folder paths)</span>
        <span class="n">before_filter_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span> <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()]</span>
        <span class="n">after_filter_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before_filter_count</span> <span class="o">&gt;</span> <span class="n">after_filter_count</span><span class="p">:</span>
            <span class="n">filtered_count</span> <span class="o">=</span> <span class="n">before_filter_count</span> <span class="o">-</span> <span class="n">after_filter_count</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtered out </span><span class="si">{</span><span class="n">filtered_count</span><span class="si">}</span><span class="s2"> non-directory items (files) from glob results&quot;</span><span class="p">)</span>

        <span class="c1"># if mode != &#39;noday&#39;:</span>
        <span class="c1">#     self.__bin_folders = [x for x in self.__bin_folders if datetime.strptime(Path(x).name, self.date_format)]</span>
        <span class="n">truncate</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parse_truncate</span><span class="p">(</span><span class="n">truncate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">truncate</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AnimalOrganizer will be truncated to the first </span><span class="si">{</span><span class="n">truncate</span><span class="si">}</span><span class="s2"> LongRecordings&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">[:</span><span class="n">truncate</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">y</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">skip_days</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bin_folder_pattern: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_pattern</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self._bin_folders: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.bin_folder_names: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;noday&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Animal ID &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">anim_id</span><span class="si">}</span><span class="s2">&#39; is not unique, found: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No directories found for animal ID </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">anim_id</span><span class="si">}</span><span class="s2"> (pattern: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_pattern</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_animalday_dicts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">core</span><span class="o">.</span><span class="n">parse_path_to_animalday</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">animal_param</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_param</span><span class="p">,</span> <span class="n">day_sep</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">day_sep</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_mode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span>
        <span class="p">]</span>

        <span class="c1"># Group folders by parsed animalday to handle overlapping days</span>
        <span class="n">animalday_to_folders</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">folder</span><span class="p">,</span> <span class="n">animalday_dict</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_folders</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_animalday_dicts</span><span class="p">):</span>
            <span class="n">animalday</span> <span class="o">=</span> <span class="n">animalday_dict</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">animalday</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">animalday_to_folders</span><span class="p">:</span>
                <span class="n">animalday_to_folders</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">animalday_to_folders</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

        <span class="c1"># Store grouping info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_animalday_folder_groups</span> <span class="o">=</span> <span class="n">animalday_to_folders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_animaldays</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">animalday_to_folders</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Log merging operations for overlapping days</span>
        <span class="n">overlapping_days</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">folders</span> <span class="ow">in</span> <span class="n">animalday_to_folders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">folders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">overlapping_days</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Merging </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">folders</span><span class="p">)</span><span class="si">}</span><span class="s2"> folders for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">folders</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overlapping_days</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">overlapping_days</span><span class="si">}</span><span class="s2"> animaldays with overlapping folders&quot;</span><span class="p">)</span>

        <span class="c1"># Update animaldays to reflect unique days (not total folders)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_animaldays</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.animaldays (unique): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">genotypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;genotype&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_animalday_dicts</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">genotypes</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inconsistent genotypes in </span><span class="si">{</span><span class="n">genotypes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span> <span class="o">=</span> <span class="n">genotypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.genotype: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">long_analyzers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">LongRecordingAnalyzer</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_animaldays</span><span class="p">)</span><span class="si">}</span><span class="s2"> LongRecordings (one per unique animalday)&quot;</span><span class="p">)</span>

        <span class="c1"># Process manual_datetimes if provided in lro_kwargs</span>
        <span class="k">if</span> <span class="s2">&quot;manual_datetimes&quot;</span> <span class="ow">in</span> <span class="n">lro_kwargs</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Processing manual_datetimes configuration&quot;</span><span class="p">)</span>
            <span class="n">base_lro_kwargs</span> <span class="o">=</span> <span class="n">lro_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">base_lro_kwargs</span><span class="p">[</span><span class="s2">&quot;manual_datetimes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_all_timestamps</span><span class="p">(</span>
                <span class="n">lro_kwargs</span><span class="p">[</span><span class="s2">&quot;manual_datetimes&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_animalday_folder_groups</span><span class="p">,</span> <span class="n">base_lro_kwargs</span>
            <span class="p">)</span>
            <span class="c1"># Remove from lro_kwargs since we&#39;ll handle it manually</span>
            <span class="n">lro_kwargs</span> <span class="o">=</span> <span class="n">base_lro_kwargs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_timestamps</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Create LongRecordingOrganizer instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_long_recordings</span><span class="p">(</span><span class="n">lro_kwargs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_timestamp_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_spec</span><span class="p">,</span> <span class="n">folder_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively resolve any timestamp input type to concrete datetime(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            input_spec: datetime, List[datetime], or Callable returning either</span>
<span class="sd">            folder_path: Path to folder for function execution context</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[datetime, List[datetime]]: Resolved timestamp(s)</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If input_spec is not a supported type</span>
<span class="sd">            Exception: If user function fails (wrapped with context)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_spec</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">input_spec</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Validate that all items are datetime objects</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">input_spec</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;All items in timestamp list must be datetime objects, got: </span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">input_spec</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">input_spec</span>

        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">input_spec</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Executing user timestamp function on folder: </span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">input_spec</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
                <span class="c1"># Recursively process the result (functions can return datetime or list)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_timestamp_input</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">folder_path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;User timestamp function failed on folder &#39;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;User timestamp function failed on folder &#39;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid timestamp input type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">input_spec</span><span class="p">)</span><span class="si">}</span><span class="s2">. Expected: datetime, List[datetime], or Callable&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_folder_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">animalday_to_folders</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find folder path by name in the animalday groups.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">folders</span> <span class="ow">in</span> <span class="n">animalday_to_folders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">folders</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">folder_name</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

        <span class="n">available_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">folders</span> <span class="ow">in</span> <span class="n">animalday_to_folders</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">available_names</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Path</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">folders</span><span class="p">])</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder name &#39;</span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2">&#39; not found. Available folders: </span><span class="si">{</span><span class="n">available_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_global_timeline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">base_datetime</span><span class="p">:</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">animalday_to_folders</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">base_lro_kwargs</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute contiguous timeline for all folders starting from base_datetime.</span>

<span class="sd">        This uses a two-pass approach:</span>
<span class="sd">        1. Create temporary LROs to determine durations</span>
<span class="sd">        2. Compute continuous start times based on cumulative durations</span>
<span class="sd">        3. Return timeline mapping for final LRO creation</span>

<span class="sd">        Args:</span>
<span class="sd">            base_datetime: Starting datetime for the timeline</span>
<span class="sd">            animalday_to_folders: Mapping of animalday -&gt; list of folder paths</span>
<span class="sd">            base_lro_kwargs: Base kwargs for LRO construction (without manual_datetimes)</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Mapping of folder_name -&gt; start_datetime for continuous timeline</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_folders</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">folders</span><span class="p">)</span> <span class="k">for</span> <span class="n">folders</span> <span class="ow">in</span> <span class="n">animalday_to_folders</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">total_animaldays</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">animalday_to_folders</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Computing continuous timeline for </span><span class="si">{</span><span class="n">total_animaldays</span><span class="si">}</span><span class="s2"> animaldays (</span><span class="si">{</span><span class="n">total_folders</span><span class="si">}</span><span class="s2"> total folders) &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;starting at </span><span class="si">{</span><span class="n">base_datetime</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Step 1: Create temporary LROs to determine durations</span>
        <span class="c1"># We need to create LROs in the order they will appear in the final timeline</span>
        <span class="n">ordered_folders</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">animalday</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">animalday_to_folders</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">folders</span> <span class="o">=</span> <span class="n">animalday_to_folders</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">folders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># For overlapping folders, we need to sort them by temporal order</span>
                <span class="c1"># Create temp LROs to get timing info for sorting</span>
                <span class="n">folder_lro_pairs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">folders</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">temp_lro</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingOrganizer</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="o">**</span><span class="n">base_lro_kwargs</span><span class="p">)</span>
                        <span class="n">folder_lro_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">folder</span><span class="p">,</span> <span class="n">temp_lro</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to create temp LRO for duration estimation in </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># Use folder order as fallback</span>
                        <span class="n">folder_lro_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">folder</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

                <span class="c1"># Sort by median time if possible</span>
                <span class="n">sorted_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_lros_by_median_time</span><span class="p">(</span><span class="n">folder_lro_pairs</span><span class="p">)</span>
                <span class="n">ordered_folders</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">folder</span> <span class="k">for</span> <span class="n">folder</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sorted_pairs</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ordered_folders</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">folders</span><span class="p">)</span>

        <span class="c1"># Step 2: Estimate total duration for each folder</span>
        <span class="n">folder_durations</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">ordered_folders</span><span class="p">:</span>
            <span class="c1"># Create temporary LRO to get duration</span>
            <span class="n">temp_lro</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingOrganizer</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="o">**</span><span class="n">base_lro_kwargs</span><span class="p">)</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">temp_lro</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">temp_lro</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">temp_lro</span><span class="o">.</span><span class="n">LongRecording</span>
                <span class="k">else</span> <span class="mf">0.0</span>
            <span class="p">)</span>
            <span class="n">folder_durations</span><span class="p">[</span><span class="n">folder</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder </span><span class="si">{</span><span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: estimated duration = </span><span class="si">{</span><span class="n">duration</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="c1"># Step 3: Compute continuous start times</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">current_start_time</span> <span class="o">=</span> <span class="n">base_datetime</span>

        <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">ordered_folders</span><span class="p">:</span>
            <span class="n">folder_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
            <span class="n">result</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_start_time</span>

            <span class="c1"># Move to next start time (current start + duration)</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">folder_durations</span><span class="p">[</span><span class="n">folder</span><span class="p">]</span>
            <span class="n">current_start_time</span> <span class="o">=</span> <span class="n">current_start_time</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">duration</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Timeline: </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2"> starts at </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span><span class="si">}</span><span class="s2">, duration </span><span class="si">{</span><span class="n">duration</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="n">total_timeline_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">folder_durations</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Continuous timeline computed: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2"> folders, total duration </span><span class="si">{</span><span class="n">total_timeline_duration</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_all_timestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manual_datetimes</span><span class="p">,</span> <span class="n">animalday_to_folders</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">base_lro_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the top-level manual_datetimes input and return folder_name -&gt; resolved_timestamps mapping.</span>

<span class="sd">        Args:</span>
<span class="sd">            manual_datetimes: Any supported timestamp input type</span>
<span class="sd">            animalday_to_folders: Mapping of animalday -&gt; list of folder paths</span>
<span class="sd">            base_lro_kwargs: Base kwargs for LRO construction (without manual_datetimes)</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Mapping of folder_name -&gt; Union[datetime, List[datetime]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Per-folder specification</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Processing per-folder timestamp specification&quot;</span><span class="p">)</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">folder_spec</span> <span class="ow">in</span> <span class="n">manual_datetimes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">folder_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_folder_by_name</span><span class="p">(</span><span class="n">folder_name</span><span class="p">,</span> <span class="n">animalday_to_folders</span><span class="p">)</span>
                <span class="n">resolved</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_timestamp_input</span><span class="p">(</span><span class="n">folder_spec</span><span class="p">,</span> <span class="n">folder_path</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resolved timestamps for </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">resolved</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">resolved</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="c1"># Global timeline - compute contiguous spacing</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing global timeline starting at </span><span class="si">{</span><span class="n">manual_datetimes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_global_timeline</span><span class="p">(</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="n">animalday_to_folders</span><span class="p">,</span> <span class="n">base_lro_kwargs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Function or list at top level - apply to all folders</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Processing timestamp input for all folders&quot;</span><span class="p">)</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">folders</span> <span class="ow">in</span> <span class="n">animalday_to_folders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">folders</span><span class="p">:</span>
                    <span class="n">folder_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">resolved</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_timestamp_input</span><span class="p">(</span><span class="n">manual_datetimes</span><span class="p">,</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">))</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resolved timestamps for </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">resolved</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">resolved</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_lro_kwargs_for_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">base_lro_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the appropriate lro_kwargs for a specific folder, including processed timestamps if available.</span>

<span class="sd">        Args:</span>
<span class="sd">            folder_path: Path to the folder</span>
<span class="sd">            base_lro_kwargs: Base kwargs to extend</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: lro_kwargs with manual_datetimes added if available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processed_timestamps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base_lro_kwargs</span>

        <span class="n">folder_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">folder_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processed_timestamps</span><span class="p">:</span>
            <span class="c1"># Add the processed timestamps for this folder</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">base_lro_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;manual_datetimes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processed_timestamps</span><span class="p">[</span><span class="n">folder_name</span><span class="p">]</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using processed timestamps for folder </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;manual_datetimes&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kwargs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No processed timestamps for this folder - use base kwargs</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No processed timestamps for folder </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2">, using base kwargs&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">base_lro_kwargs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log_timeline_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log timeline summary for debugging purposes.&quot;&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AnimalOrganizer Timeline Summary:&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;No LongRecordings created&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lro</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lro_start_time</span><span class="p">(</span><span class="n">lro</span><span class="p">)</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lro_end_time</span><span class="p">(</span><span class="n">lro</span><span class="p">)</span>
                    <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="p">)</span>
                    <span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lro</span><span class="o">.</span><span class="n">file_durations</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;file_durations&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_durations</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="n">folder_path</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;base_folder_path&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">)</span>

                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;LRO </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2"> → </span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(duration: </span><span class="si">{</span><span class="n">duration</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s, files: </span><span class="si">{</span><span class="n">n_files</span><span class="si">}</span><span class="s2">, folder: </span><span class="si">{</span><span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to get timeline info for LRO </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_lro_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lro</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the start time of an LRO.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;file_end_datetimes&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;file_durations&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_durations</span><span class="p">:</span>
                <span class="c1"># Calculate start time from first end time and duration</span>
                <span class="n">first_end</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dt</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">first_duration</span> <span class="o">=</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_durations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">first_end</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">first_duration</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;unknown&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_lro_end_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lro</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the end time of an LRO.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;file_end_datetimes&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">:</span>
            <span class="c1"># Get the last non-None end time</span>
            <span class="n">end_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">dt</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">end_times</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_times</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;unknown&quot;</span>

<div class="viewcode-block" id="AnimalOrganizer.get_timeline_summary">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.get_timeline_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_timeline_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get timeline summary as a DataFrame for user inspection and debugging.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Timeline information with columns:</span>
<span class="sd">                - lro_index: Index of the LRO</span>
<span class="sd">                - start_time: Start datetime of the LRO</span>
<span class="sd">                - end_time: End datetime of the LRO</span>
<span class="sd">                - duration_s: Duration in seconds</span>
<span class="sd">                - n_files: Number of files in the LRO</span>
<span class="sd">                - folder_path: Base folder path</span>
<span class="sd">                - animalday: Parsed animalday identifier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="n">timeline_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lro</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lro_start_time</span><span class="p">(</span><span class="n">lro</span><span class="p">)</span>
                <span class="n">end_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lro_end_time</span><span class="p">(</span><span class="n">lro</span><span class="p">)</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lro</span><span class="o">.</span><span class="n">file_durations</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;file_durations&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_durations</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="n">folder_path</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;base_folder_path&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">)</span>

                <span class="n">timeline_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;lro_index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                        <span class="s2">&quot;start_time&quot;</span><span class="p">:</span> <span class="n">start_time</span><span class="p">,</span>
                        <span class="s2">&quot;end_time&quot;</span><span class="p">:</span> <span class="n">end_time</span><span class="p">,</span>
                        <span class="s2">&quot;duration_s&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
                        <span class="s2">&quot;n_files&quot;</span><span class="p">:</span> <span class="n">n_files</span><span class="p">,</span>
                        <span class="s2">&quot;folder_path&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">folder_path</span><span class="p">),</span>
                        <span class="s2">&quot;folder_name&quot;</span><span class="p">:</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">folder_path</span> <span class="o">!=</span> <span class="s2">&quot;unknown&quot;</span> <span class="k">else</span> <span class="s2">&quot;unknown&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;animalday&quot;</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span>
                            <span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;_animalday&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span>
                        <span class="p">),</span>  <span class="c1"># This might not exist, but useful if it does</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Include failed LROs in the summary for debugging</span>
                <span class="n">timeline_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;lro_index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                        <span class="s2">&quot;start_time&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;end_time&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;duration_s&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="s2">&quot;n_files&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="s2">&quot;folder_path&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;folder_name&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;animalday&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">timeline_data</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_long_recordings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lro_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create LongRecordingOrganizer instances for each unique animalday.&quot;&quot;&quot;</span>
        <span class="c1"># Create one LRO per unique animalday (not per folder)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">LongRecordingOrganizer</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">folders</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_animalday_folder_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">folders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Single folder - use processed timestamps if available</span>
                <span class="n">folder_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lro_kwargs_for_folder</span><span class="p">(</span><span class="n">folders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lro_kwargs</span><span class="p">)</span>
                <span class="n">lro</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingOrganizer</span><span class="p">(</span><span class="n">folders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">folder_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Multiple folders - create individual LROs then sort and merge</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating individual LROs for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">folders</span><span class="p">)</span><span class="si">}</span><span class="s2"> folders for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Create individual LROs first, each with their own processed timestamps</span>
                <span class="n">folder_lro_pairs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">folders</span><span class="p">:</span>
                    <span class="n">folder_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lro_kwargs_for_folder</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">lro_kwargs</span><span class="p">)</span>
                    <span class="n">individual_lro</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingOrganizer</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="o">**</span><span class="n">folder_kwargs</span><span class="p">)</span>
                    <span class="n">folder_lro_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">folder</span><span class="p">,</span> <span class="n">individual_lro</span><span class="p">))</span>

                <span class="c1"># Sort by median time using constructed LROs</span>
                <span class="n">sorted_folder_lro_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_lros_by_median_time</span><span class="p">(</span><span class="n">folder_lro_pairs</span><span class="p">)</span>

                <span class="c1"># Debug logging to show the order of LROs being merged</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;LRO merge order for overlapping animalday:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">lro</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_folder_lro_pairs</span><span class="p">):</span>
                    <span class="n">folder_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
                    <span class="c1"># Handle mock objects gracefully</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span>
                            <span class="k">else</span> <span class="mi">0</span>
                        <span class="p">)</span>
                        <span class="n">duration_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                        <span class="n">duration_str</span> <span class="o">=</span> <span class="s2">&quot;mock&quot;</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2"> (duration: </span><span class="si">{</span><span class="n">duration_str</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                <span class="c1"># Merge all LROs into the first one (in temporal order)</span>
                <span class="n">merged_lro</span> <span class="o">=</span> <span class="n">sorted_folder_lro_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Get the LRO from first tuple</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Base LRO: </span><span class="si">{</span><span class="n">Path</span><span class="p">(</span><span class="n">sorted_folder_lro_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">lro</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_folder_lro_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">folder_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Merging LRO </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2"> into base LRO&quot;</span><span class="p">)</span>
                    <span class="n">merged_lro</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">lro</span><span class="p">)</span>

                <span class="n">lro</span> <span class="o">=</span> <span class="n">merged_lro</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully merged </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_folder_lro_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2"> LROs for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lro</span><span class="p">)</span>

        <span class="c1"># Log timeline summary for debugging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_timeline_summary</span><span class="p">()</span>

        <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">channel_names</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">channel_names</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inconsistent channel names in long_recordings: </span><span class="si">{</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="n">channel_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">animal_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;animal&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_animalday_dicts</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">animal_ids</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inconsistent animal IDs in </span><span class="si">{</span><span class="n">animal_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span> <span class="o">=</span> <span class="n">animal_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features_avg_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sort_lros_by_median_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder_lro_pairs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sort LROs by median timestamp of their constituent recordings.</span>

<span class="sd">        Args:</span>
<span class="sd">            folder_lro_pairs (list): List of (folder_path, lro) tuples</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: Sorted (folder_path, lro) tuples in temporal order based on median timestamp</span>

<span class="sd">        Note:</span>
<span class="sd">            Extracts file_end_datetimes from each LRO (timestamps from LastEdit fields in metadata CSV files),</span>
<span class="sd">            calculates the median timestamp of constituent recordings within each LRO, and sorts LROs</span>
<span class="sd">            by this median timestamp. This ensures proper temporal ordering based on actual recording</span>
<span class="sd">            content rather than folder naming conventions. Falls back to folder modification time if</span>
<span class="sd">            no valid timestamps are available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">folder_lro_pairs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">folder_lro_pairs</span>

        <span class="n">folder_lro_times</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">folder_path</span><span class="p">,</span> <span class="n">lro</span> <span class="ow">in</span> <span class="n">folder_lro_pairs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Get median timestamp from constituent recordings within the LRO</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;file_end_datetimes&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">valid_timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span> <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="n">valid_timestamps</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">valid_timestamps</span><span class="p">:</span>
                        <span class="c1"># Sort timestamps and get the median</span>
                        <span class="n">valid_timestamps</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                        <span class="n">n_timestamps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_timestamps</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">n_timestamps</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># Odd number of timestamps - take middle one</span>
                            <span class="n">median_timestamp</span> <span class="o">=</span> <span class="n">valid_timestamps</span><span class="p">[</span><span class="n">n_timestamps</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Even number of timestamps - take average of two middle ones</span>
                            <span class="n">mid1</span> <span class="o">=</span> <span class="n">valid_timestamps</span><span class="p">[</span><span class="n">n_timestamps</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="n">mid2</span> <span class="o">=</span> <span class="n">valid_timestamps</span><span class="p">[</span><span class="n">n_timestamps</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="n">median_timestamp</span> <span class="o">=</span> <span class="n">mid1</span> <span class="o">+</span> <span class="p">(</span><span class="n">mid2</span> <span class="o">-</span> <span class="n">mid1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

                        <span class="c1"># Convert to seconds since epoch for sorting</span>
                        <span class="n">median_time_seconds</span> <span class="o">=</span> <span class="n">median_timestamp</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;LRO </span><span class="si">{</span><span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">n_timestamps</span><span class="si">}</span><span class="s2"> recordings, median timestamp: </span><span class="si">{</span><span class="n">median_timestamp</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No file_end_datetimes available in LRO </span><span class="si">{</span><span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, cannot determine temporal order&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No file_end_datetimes available in LRO </span><span class="si">{</span><span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, cannot determine temporal order&quot;</span><span class="p">)</span>

                <span class="n">folder_lro_times</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">lro</span><span class="p">,</span> <span class="n">median_time_seconds</span><span class="p">))</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not extract timing from </span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="c1"># Sort by median time</span>
        <span class="n">sorted_folder_lro_times</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">folder_lro_times</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">sorted_folder_lro_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">folder</span><span class="p">,</span> <span class="n">lro</span><span class="p">)</span> <span class="k">for</span> <span class="n">folder</span><span class="p">,</span> <span class="n">lro</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sorted_folder_lro_times</span><span class="p">]</span>

        <span class="c1"># Log the sorting for debugging</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">folder_lro_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;LRO temporal sorting details:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">lro</span><span class="p">,</span> <span class="n">median_time_seconds</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_folder_lro_times</span><span class="p">):</span>
                <span class="n">folder_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>

                <span class="c1"># Convert back to datetime for readable logging</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

                    <span class="n">median_datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">median_time_seconds</span><span class="p">)</span>
                    <span class="n">median_time_str</span> <span class="o">=</span> <span class="n">median_datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
                    <span class="n">median_time_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">median_time_seconds</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span>

                <span class="c1"># Handle mock objects gracefully for duration</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;LongRecording&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">LongRecording</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="p">)</span>
                    <span class="n">duration_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="n">duration_str</span> <span class="o">=</span> <span class="s2">&quot;mock&quot;</span>

                <span class="c1"># Show number of recordings in LRO</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">n_recordings</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lro</span><span class="p">,</span> <span class="s2">&quot;file_end_datetimes&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lro</span><span class="o">.</span><span class="n">file_end_datetimes</span>
                        <span class="k">else</span> <span class="mi">0</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                    <span class="n">n_recordings</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">folder_name</span><span class="si">}</span><span class="s2">: median_timestamp=</span><span class="si">{</span><span class="n">median_time_str</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">n_recordings</span><span class="si">}</span><span class="s2"> recordings, duration=</span><span class="si">{</span><span class="n">duration_str</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Summary line for quick reference</span>
            <span class="n">folder_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sorted_folder_lro_times</span><span class="p">]</span>
            <span class="n">median_times</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">median_time_seconds</span> <span class="ow">in</span> <span class="n">sorted_folder_lro_times</span><span class="p">:</span>
                <span class="n">median_datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">median_time_seconds</span><span class="p">)</span>
                <span class="n">median_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">median_datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%H:%M:%S&quot;</span><span class="p">))</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final sort order: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">folder_names</span><span class="p">,</span><span class="w"> </span><span class="n">median_times</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sorted_folder_lro_pairs</span>

<div class="viewcode-block" id="AnimalOrganizer.convert_colbins_to_rowbins">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.convert_colbins_to_rowbins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_colbins_to_rowbins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Converting column bins to row bins&quot;</span><span class="p">):</span>
            <span class="n">lrec</span><span class="o">.</span><span class="n">convert_colbins_to_rowbins</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnimalOrganizer.convert_rowbins_to_rec">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.convert_rowbins_to_rec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_rowbins_to_rec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Converting row bins to recs&quot;</span><span class="p">):</span>
            <span class="n">lrec</span><span class="o">.</span><span class="n">convert_rowbins_to_rec</span><span class="p">(</span><span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnimalOrganizer.cleanup_rec">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.cleanup_rec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cleanup_rec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">:</span>
            <span class="n">lrec</span><span class="o">.</span><span class="n">cleanup_rec</span><span class="p">()</span></div>


<div class="viewcode-block" id="AnimalOrganizer.compute_bad_channels">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.compute_bad_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_bad_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lof_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">force_recompute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute bad channels using LOF analysis for all recordings.</span>

<span class="sd">        Args:</span>
<span class="sd">            lof_threshold (float, optional): Threshold for determining bad channels from LOF scores.</span>
<span class="sd">                                           If None, only computes/loads scores without setting bad_channel_names.</span>
<span class="sd">            force_recompute (bool): Whether to recompute LOF scores even if they exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Computing bad channels for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">)</span><span class="si">}</span><span class="s2"> recordings with threshold=</span><span class="si">{</span><span class="n">lof_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing bad channels for recording </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">lrec</span><span class="o">.</span><span class="n">compute_bad_channels</span><span class="p">(</span><span class="n">lof_threshold</span><span class="o">=</span><span class="n">lof_threshold</span><span class="p">,</span> <span class="n">force_recompute</span><span class="o">=</span><span class="n">force_recompute</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Recording </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> LOF scores computed: </span><span class="si">{</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">lrec</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;lof_scores&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">lrec</span><span class="o">.</span><span class="n">lof_scores</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Update bad channels dict if threshold was applied</span>
        <span class="k">if</span> <span class="n">lof_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">animalday</span><span class="p">:</span> <span class="n">lrec</span><span class="o">.</span><span class="n">bad_channel_names</span> <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">)</span>
            <span class="p">}</span></div>


<div class="viewcode-block" id="AnimalOrganizer.apply_lof_threshold">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.apply_lof_threshold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_lof_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lof_threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply threshold to existing LOF scores to determine bad channels for all recordings.</span>

<span class="sd">        Args:</span>
<span class="sd">            lof_threshold (float): Threshold for determining bad channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">:</span>
            <span class="n">lrec</span><span class="o">.</span><span class="n">apply_lof_threshold</span><span class="p">(</span><span class="n">lof_threshold</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">animalday</span><span class="p">:</span> <span class="n">lrec</span><span class="o">.</span><span class="n">bad_channel_names</span> <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">)</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="AnimalOrganizer.get_all_lof_scores">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.get_all_lof_scores">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_all_lof_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get LOF scores for all recordings.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary mapping animal days to LOF score dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">animalday</span><span class="p">:</span> <span class="n">lrec</span><span class="o">.</span><span class="n">get_lof_scores</span><span class="p">()</span> <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">)}</span></div>


<div class="viewcode-block" id="AnimalOrganizer.compute_windowed_analysis">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.compute_windowed_analysis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_windowed_analysis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">exclude</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">window_s</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">,</span>
        <span class="n">suppress_short_interval_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_notch_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes windowed analysis of animal recordings. The data is divided into windows (time bins), then features are extracted from each window. The result is</span>
<span class="sd">        formatted to a Dataframe and wrapped into a WindowAnalysisResult object.</span>

<span class="sd">        Args:</span>
<span class="sd">            features (list[str]): List of features to compute. See individual ``compute_...()`` functions for output format</span>
<span class="sd">            exclude (list[str], optional): List of features to ignore. Will override the features parameter. Defaults to [].</span>
<span class="sd">            window_s (int, optional): Length of each window in seconds. Note that some features break with very short window times. Defaults to 4.</span>
<span class="sd">            suppress_short_interval_error (bool, optional): If True, suppress ValueError for short intervals between timestamps in resulting WindowAnalysisResult. Useful for aggregated WARs. Defaults to False.</span>
<span class="sd">            apply_notch_filter (bool, optional): Whether to apply notch filtering to remove line noise. Uses constants.LINE_FREQ. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If a feature&#39;s ``compute_...()`` function was not implemented, this error will be raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: A WindowAnalysisResult object containing extracted features for all recordings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">_sanitize_feature_request</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

        <span class="n">dataframes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">:</span>  <span class="c1"># Iterate over all long recordings</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing windowed analysis for </span><span class="si">{</span><span class="n">lrec</span><span class="o">.</span><span class="n">base_folder_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">lan</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingAnalyzer</span><span class="p">(</span><span class="n">lrec</span><span class="p">,</span> <span class="n">fragment_len_s</span><span class="o">=</span><span class="n">window_s</span><span class="p">,</span> <span class="n">apply_notch_filter</span><span class="o">=</span><span class="n">apply_notch_filter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lan</span><span class="o">.</span><span class="n">n_fragments</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No fragments found for </span><span class="si">{</span><span class="n">lrec</span><span class="o">.</span><span class="n">base_folder_path</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">lan</span><span class="o">.</span><span class="n">n_fragments</span><span class="si">}</span><span class="s2"> fragments&quot;</span><span class="p">)</span>
            <span class="n">miniters</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lan</span><span class="o">.</span><span class="n">n_fragments</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
            <span class="k">match</span> <span class="n">multiprocess_mode</span><span class="p">:</span>
                <span class="k">case</span> <span class="s2">&quot;dask&quot;</span><span class="p">:</span>
                    <span class="c1"># The last fragment is not included because it makes the dask array ragged</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Converting LongRecording to numpy array&quot;</span><span class="p">)</span>

                    <span class="n">n_fragments_war</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lan</span><span class="o">.</span><span class="n">n_fragments</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">first_fragment</span> <span class="o">=</span> <span class="n">lan</span><span class="o">.</span><span class="n">get_fragment_np</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">np_fragments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_fragments_war</span><span class="p">,)</span> <span class="o">+</span> <span class="n">first_fragment</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">first_fragment</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np_fragments.shape: </span><span class="si">{</span><span class="n">np_fragments</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_fragments_war</span><span class="p">):</span>
                        <span class="n">np_fragments</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lan</span><span class="o">.</span><span class="n">get_fragment_np</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                    <span class="c1"># Cache fragments to zarr</span>
                    <span class="n">tmppath</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cache_fragments_to_zarr</span><span class="p">(</span><span class="n">np_fragments</span><span class="p">,</span> <span class="n">n_fragments_war</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">np_fragments</span>

                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Processing metadata serially&quot;</span><span class="p">)</span>
                    <span class="n">metadatas</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_fragment_metadata</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lan</span><span class="p">,</span> <span class="n">window_s</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_fragments_war</span><span class="p">)]</span>
                    <span class="n">meta_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">metadatas</span><span class="p">)</span>

                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Processing features in parallel&quot;</span><span class="p">)</span>
                    <span class="n">np_fragments_reconstruct</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_zarr</span><span class="p">(</span><span class="n">tmppath</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dask array shape: </span><span class="si">{</span><span class="n">np_fragments_reconstruct</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dask array chunks: </span><span class="si">{</span><span class="n">np_fragments_reconstruct</span><span class="o">.</span><span class="n">chunks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Create delayed tasks for each fragment using efficient dependency resolution</span>
                    <span class="n">feature_values</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">delayed</span><span class="p">(</span><span class="n">FragmentAnalyzer</span><span class="o">.</span><span class="n">process_fragment_with_dependencies</span><span class="p">)(</span>
                            <span class="n">np_fragments_reconstruct</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">lan</span><span class="o">.</span><span class="n">f_s</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">kwargs</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_fragments_war</span><span class="p">)</span>
                    <span class="p">]</span>

                    <span class="c1"># Compute features in parallel</span>
                    <span class="n">feature_values</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">feature_values</span><span class="p">)</span>

                    <span class="c1"># Clean up temp directory after processing</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cleaning up temp directory&quot;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="kn">import</span><span class="w"> </span><span class="nn">shutil</span>

                        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmppath</span><span class="p">)</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">FileNotFoundError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to remove temporary directory </span><span class="si">{</span><span class="n">tmppath</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Combining metadata and feature values&quot;</span><span class="p">)</span>
                    <span class="n">feat_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">feature_values</span><span class="p">)</span>
                    <span class="n">lan_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">meta_df</span><span class="p">,</span> <span class="n">feat_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Processing serially&quot;</span><span class="p">)</span>
                    <span class="n">lan_df</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lan</span><span class="o">.</span><span class="n">n_fragments</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing rows&quot;</span><span class="p">,</span> <span class="n">miniters</span><span class="o">=</span><span class="n">miniters</span><span class="p">):</span>
                        <span class="n">lan_df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_fragment_serial</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">lan</span><span class="p">,</span> <span class="n">window_s</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>

            <span class="n">lan_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lan_df</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Validating timestamps&quot;</span><span class="p">)</span>
            <span class="n">core</span><span class="o">.</span><span class="n">validate_timestamps</span><span class="p">(</span><span class="n">lan_df</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">lan_df</span> <span class="o">=</span> <span class="n">lan_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;timestamp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">long_analyzers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lan</span><span class="p">)</span>
            <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lan_df</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">features_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dataframes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features_df</span>

        <span class="c1"># Collect LOF scores from long recordings</span>
        <span class="n">lof_scores_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Checking LOF scores for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">: has_attr=</span><span class="si">{</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">lrec</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;lof_scores&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;is_not_none=</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">lrec</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;lof_scores&#39;</span><span class="p">,</span><span class="w"> </span><span class="kc">None</span><span class="p">)</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lrec</span><span class="p">,</span> <span class="s2">&quot;lof_scores&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lrec</span><span class="o">.</span><span class="n">lof_scores</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lof_scores_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;lof_scores&quot;</span><span class="p">:</span> <span class="n">lrec</span><span class="o">.</span><span class="n">lof_scores</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                    <span class="s2">&quot;channel_names&quot;</span><span class="p">:</span> <span class="n">lrec</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added LOF scores for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">lrec</span><span class="o">.</span><span class="n">lof_scores</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels&quot;</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total LOF scores collected: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">lof_scores_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> animal days&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">window_analysis_result</span> <span class="o">=</span> <span class="n">WindowAnalysisResult</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">features_df</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="p">,</span>
            <span class="n">suppress_short_interval_error</span><span class="p">,</span>
            <span class="n">lof_scores_dict</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_analysis_result</span></div>


<div class="viewcode-block" id="AnimalOrganizer.compute_spike_analysis">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.compute_spike_analysis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_spike_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;SpikeAnalysisResult&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute spike sorting on all long recordings and return a list of SpikeAnalysisResult objects</span>

<span class="sd">        Args:</span>
<span class="sd">            multiprocess_mode (Literal[&#39;dask&#39;, &#39;serial&#39;]): Whether to use Dask for parallel processing. Defaults to &#39;serial&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[SpikeAnalysisResult]: List of SpikeAnalysisResult objects. Each SpikeAnalysisResult object corresponds</span>
<span class="sd">                to a LongRecording object, typically a different day or recording session.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ImportError: If mountainsort5 is not available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if mountainsort5 is available</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">MOUNTAINSORT_AVAILABLE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Spike analysis requires mountainsort5. Install it with: pip install mountainsort5&quot;</span><span class="p">)</span>
        <span class="n">sars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lrec_sorts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lrec_recs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">recs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lrec</span><span class="o">.</span><span class="n">LongRecording</span> <span class="k">for</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sorting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span><span class="si">}</span><span class="s2"> recordings&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">recs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">get_total_samples</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">rec</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="si">}</span><span class="s2"> because it has no samples&quot;</span><span class="p">)</span>
                <span class="n">sortings</span><span class="p">,</span> <span class="n">recordings</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sortings</span><span class="p">,</span> <span class="n">recordings</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">MountainSortAnalyzer</span><span class="o">.</span><span class="n">sort_recording</span><span class="p">(</span>
                    <span class="n">rec</span><span class="p">,</span> <span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span>
                <span class="p">)</span>
            <span class="n">lrec_sorts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortings</span><span class="p">)</span>
            <span class="n">lrec_recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recordings</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multiprocess_mode</span> <span class="o">==</span> <span class="s2">&quot;dask&quot;</span><span class="p">:</span>
            <span class="n">lrec_sorts</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">lrec_sorts</span><span class="p">)</span>

        <span class="n">lrec_sas</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">si</span><span class="o">.</span><span class="n">create_sorting_analyzer</span><span class="p">(</span><span class="n">sorting</span><span class="p">,</span> <span class="n">recording</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sorting</span><span class="p">,</span> <span class="n">recording</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sortings</span><span class="p">,</span> <span class="n">recordings</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">sortings</span><span class="p">,</span> <span class="n">recordings</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lrec_sorts</span><span class="p">,</span> <span class="n">lrec_recs</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">sars</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">SpikeAnalysisResult</span><span class="p">(</span>
                <span class="n">result_sas</span><span class="o">=</span><span class="n">sas</span><span class="p">,</span>
                <span class="n">result_mne</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">animal_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
                <span class="n">genotype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
                <span class="n">animal_day</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">bin_folder_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span>
                <span class="n">channel_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
                <span class="n">assume_from_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sas</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lrec_sas</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spike_analysis_results</span> <span class="o">=</span> <span class="n">sars</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_analysis_results</span></div>


<div class="viewcode-block" id="AnimalOrganizer.compute_frequency_domain_spike_analysis">
<a class="viewcode-back" href="../../../api/visualization/animal_organizer.html#neurodent.visualization.AnimalOrganizer.compute_frequency_domain_spike_analysis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_frequency_domain_spike_analysis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">detection_params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">multiprocess_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;serial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;serial&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute frequency-domain spike detection on all long recordings.</span>

<span class="sd">        Args:</span>
<span class="sd">            detection_params (dict, optional): Detection parameters. Uses defaults if None.</span>
<span class="sd">            max_length (int, optional): Maximum length in samples to analyze per recording</span>
<span class="sd">            multiprocess_mode (Literal[&quot;dask&quot;, &quot;serial&quot;]): Processing mode</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[FrequencyDomainSpikeAnalysisResult]: Results for each recording session</span>

<span class="sd">        Raises:</span>
<span class="sd">            ImportError: If SpikeInterface is not available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Import here to avoid circular imports</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.frequency_domain_results</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencyDomainSpikeAnalysisResult</span>

        <span class="n">fdsar_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">recs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lrec</span><span class="o">.</span><span class="n">LongRecording</span> <span class="k">for</span> <span class="n">lrec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running frequency-domain spike detection on </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span><span class="si">}</span><span class="s2"> recordings&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detection parameters: </span><span class="si">{</span><span class="n">detection_params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">recs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">get_total_samples</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">rec</span><span class="si">}</span><span class="s2"> because it has no samples&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Run frequency domain spike detection</span>
                <span class="n">spike_indices_per_channel</span><span class="p">,</span> <span class="n">mne_raw_with_annotations</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">FrequencyDomainSpikeDetector</span><span class="o">.</span><span class="n">detect_spikes_recording</span><span class="p">(</span>
                        <span class="n">rec</span><span class="p">,</span>
                        <span class="n">detection_params</span><span class="o">=</span><span class="n">detection_params</span><span class="p">,</span>
                        <span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span><span class="p">,</span>
                        <span class="n">multiprocess_mode</span><span class="o">=</span><span class="n">multiprocess_mode</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Create FrequencyDomainSpikeAnalysisResult</span>
                <span class="n">fdsar</span> <span class="o">=</span> <span class="n">FrequencyDomainSpikeAnalysisResult</span><span class="o">.</span><span class="n">from_detection_results</span><span class="p">(</span>
                    <span class="n">spike_indices_per_channel</span><span class="o">=</span><span class="n">spike_indices_per_channel</span><span class="p">,</span>
                    <span class="n">mne_raw_with_annotations</span><span class="o">=</span><span class="n">mne_raw_with_annotations</span><span class="p">,</span>
                    <span class="n">detection_params</span><span class="o">=</span><span class="n">detection_params</span> <span class="ow">or</span> <span class="p">{},</span>
                    <span class="n">animal_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
                    <span class="n">genotype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
                    <span class="n">animal_day</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">bin_folder_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">long_recordings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span>
                    <span class="n">assume_from_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">fdsar_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fdsar</span><span class="p">)</span>

                <span class="c1"># Log results</span>
                <span class="n">total_spikes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span> <span class="k">for</span> <span class="n">spikes</span> <span class="ow">in</span> <span class="n">spike_indices_per_channel</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recording </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span><span class="si">}</span><span class="s2">: Detected </span><span class="si">{</span><span class="n">total_spikes</span><span class="si">}</span><span class="s2"> spikes across </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spike_indices_per_channel</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels&quot;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing recording </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="c1"># Store results for later access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequency_domain_spike_analysis_results</span> <span class="o">=</span> <span class="n">fdsar_list</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Completed frequency-domain spike detection. Total recordings processed: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fdsar_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fdsar_list</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_process_fragment_serial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">lan</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingAnalyzer</span><span class="p">,</span> <span class="n">window_s</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_fragment_metadata</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lan</span><span class="p">,</span> <span class="n">window_s</span><span class="p">)</span>
        <span class="n">row</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_fragment_features</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">lan</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">row</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_fragment_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">lan</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingAnalyzer</span><span class="p">,</span> <span class="n">window_s</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">lan_folder</span> <span class="o">=</span> <span class="n">lan</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">base_folder_path</span>
        <span class="n">animalday_dict</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">parse_path_to_animalday</span><span class="p">(</span>
            <span class="n">lan_folder</span><span class="p">,</span> <span class="n">animal_param</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_param</span><span class="p">,</span> <span class="n">day_sep</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">day_sep</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_mode</span>
        <span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">animalday_dict</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">]</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;animal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">animalday_dict</span><span class="p">[</span><span class="s2">&quot;animal&quot;</span><span class="p">]</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">animalday_dict</span><span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">]</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;genotype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">animalday_dict</span><span class="p">[</span><span class="s2">&quot;genotype&quot;</span><span class="p">]</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lan</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_dur_fragment</span><span class="p">(</span><span class="n">window_s</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;endfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lan</span><span class="o">.</span><span class="n">get_file_end</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">frag_dt</span> <span class="o">=</span> <span class="n">lan</span><span class="o">.</span><span class="n">LongRecording</span><span class="o">.</span><span class="n">get_datetime_fragment</span><span class="p">(</span><span class="n">window_s</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">frag_dt</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;isday&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_day</span><span class="p">(</span><span class="n">frag_dt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">row</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_fragment_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">lan</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">LongRecordingAnalyzer</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lan</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;compute_</span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid function </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">row</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_sanitize_feature_request</span><span class="p">(</span><span class="n">features</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sanitizes a list of requested features for WindowAnalysisResult</span>

<span class="sd">    Args:</span>
<span class="sd">        features (list[str]): List of features to include. If &quot;all&quot;, include all features in constants.FEATURES except for exclude.</span>
<span class="sd">        exclude (list[str], optional): List of features to exclude. Defaults to [].</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[str]: Sanitized list of features.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">features</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">features</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">]:</span>
        <span class="n">feat</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">FEATURES</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">features</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Features cannot be empty&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">f</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">FEATURES</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available features are: </span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">FEATURES</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">feat</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">feat</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">feat</span>


<div class="viewcode-block" id="WindowAnalysisResult">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WindowAnalysisResult</span><span class="p">(</span><span class="n">AnimalFeatureParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for output of windowed analysis. Has useful functions like group-wise and global averaging, filtering, and saving</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WindowAnalysisResult.__init__">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">animal_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">genotype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channel_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">assume_from_number</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bad_channels_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">suppress_short_interval_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lof_scores_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            result (pd.DataFrame): Result comes from AnimalOrganizer.compute_windowed_analysis()</span>
<span class="sd">            animal_id (str, optional): Identifier for the animal where result was computed from. Defaults to None.</span>
<span class="sd">            genotype (str, optional): Genotype of animal. Defaults to None.</span>
<span class="sd">            channel_names (list[str], optional): List of channel names. Defaults to None.</span>
<span class="sd">            assume_channels (bool, optional): If true, assumes channel names according to AnimalFeatureParser.DEFAULT_CHNUM_TO_NAME. Defaults to False.</span>
<span class="sd">            bad_channels_dict (dict[str, list[str]], optional): Dictionary of channels to reject for each recording session. Defaults to {}.</span>
<span class="sd">            suppress_short_interval_error (bool, optional): If True, suppress ValueError for short intervals between timestamps. Useful for aggregated WARs with large window sizes. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span> <span class="o">=</span> <span class="n">animal_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span> <span class="o">=</span> <span class="n">genotype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="n">channel_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span> <span class="o">=</span> <span class="n">assume_from_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span> <span class="o">=</span> <span class="n">suppress_short_interval_error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span> <span class="o">=</span> <span class="n">lof_scores_dict</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__update_instance_vars</span><span class="p">()</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel names: </span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel abbreviations: </span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span><span class="si">}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="WindowAnalysisResult.copy">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the WindowAnalysisResult object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: A deep copy of the current instance with all attributes copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">WindowAnalysisResult</span><span class="p">(</span>
            <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">animal_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
            <span class="n">genotype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
            <span class="n">channel_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">assume_from_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
            <span class="n">bad_channels_dict</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="p">),</span>
            <span class="n">suppress_short_interval_error</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span><span class="p">,</span>
            <span class="n">lof_scores_dict</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="p">),</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__update_instance_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run after updating self.result, or other init values&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;index&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Dropping column &#39;index&#39;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>

        <span class="c1"># Check if timestamps are sorted and sort if needed</span>
        <span class="k">if</span> <span class="s2">&quot;timestamp&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Timestamps are not sorted. Sorting result DataFrame by timestamp.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;timestamp&quot;</span><span class="p">)</span>

        <span class="c1"># Check for unusually short intervals between timestamps</span>
        <span class="k">if</span> <span class="s2">&quot;timestamp&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s2">&quot;duration&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">median_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
            <span class="n">timestamp_diffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
            <span class="n">short_intervals</span> <span class="o">=</span> <span class="n">timestamp_diffs</span> <span class="o">&lt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">median_duration</span><span class="p">)</span>

            <span class="c1"># Skip first row since diff() produces NaT</span>
            <span class="n">short_intervals</span> <span class="o">=</span> <span class="n">short_intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="k">if</span> <span class="n">short_intervals</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">n_short</span> <span class="o">=</span> <span class="n">short_intervals</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">pct_short</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_short</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">short_intervals</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span>

                <span class="n">warning_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">n_short</span><span class="si">}</span><span class="s2"> intervals (</span><span class="si">{</span><span class="n">pct_short</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%) between timestamps &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;that are shorter than the median duration of </span><span class="si">{</span><span class="n">median_duration</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">pct_short</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span><span class="p">:</span>  <span class="c1"># More than 1% of intervals are short</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">warning_msg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warning_msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;animal&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">unique_animals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;animal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_animals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiple animals found in result: </span><span class="si">{</span><span class="n">unique_animals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unique_animals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Animal ID mismatch: result has </span><span class="si">{</span><span class="n">unique_animals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, but self.animal_id is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">FEATURES</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nonfeature_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">FEATURES</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animaldays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;animalday&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">core</span><span class="o">.</span><span class="n">parse_chname_to_abbrev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">assume_from_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span>
        <span class="p">]</span>

<div class="viewcode-block" id="WindowAnalysisResult.reorder_and_pad_channels">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.reorder_and_pad_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reorder_and_pad_channels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target_channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">use_abbrevs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reorder and pad channels to match a target channel list.</span>

<span class="sd">        This method ensures that the data has a consistent channel order and structure</span>
<span class="sd">        by reordering existing channels and padding missing channels with NaNs.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_channels (list[str]): List of target channel names to match</span>
<span class="sd">            use_abbrevs (bool, optional): If True, target channel names are read as channel abbreviations instead of channel names. Defaults to True.</span>
<span class="sd">            inplace (bool, optional): If True, modify the result in place. Defaults to True.</span>
<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: DataFrame with reordered and padded channels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">target_channels</span> <span class="k">if</span> <span class="n">target_channels</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">duplicates</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target channels must be unique. Found duplicates: </span><span class="si">{</span><span class="n">duplicates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">channel_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">ch</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_channels</span><span class="p">)}</span>
        <span class="n">channel_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">use_abbrevs</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span>

        <span class="n">valid_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channel_names</span> <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channel_map</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_channels</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;None of the channel names </span><span class="si">{</span><span class="n">channel_names</span><span class="si">}</span><span class="s2"> were found in target channels </span><span class="si">{</span><span class="n">target_channels</span><span class="si">}</span><span class="s2">. Is use_abbrevs correctly set?&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_columns</span><span class="p">:</span>
            <span class="k">match</span> <span class="n">feature</span><span class="p">:</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">LINEAR_FEATURES</span> <span class="o">+</span> <span class="n">constants</span><span class="o">.</span><span class="n">BAND_FEATURES</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">BAND_FEATURES</span><span class="p">:</span>
                        <span class="n">df_bands</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df_bands</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">keys</span> <span class="o">=</span> <span class="n">df_bands</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                    <span class="n">new_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_channels</span><span class="p">),</span> <span class="o">*</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>  <span class="c1"># dubious</span>

                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channel_map</span><span class="p">:</span>
                            <span class="n">new_vals</span><span class="p">[:,</span> <span class="n">channel_map</span><span class="p">[</span><span class="n">ch</span><span class="p">]]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">BAND_FEATURES</span><span class="p">:</span>
                        <span class="n">new_vals</span> <span class="o">=</span> <span class="n">new_vals</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">))</span> <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">new_vals</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_vals</span><span class="p">]</span>

                <span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">MATRIX_FEATURES</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cohere&quot;</span><span class="p">,</span> <span class="s2">&quot;zcohere&quot;</span><span class="p">,</span> <span class="s2">&quot;imcoh&quot;</span><span class="p">,</span> <span class="s2">&quot;zimcoh&quot;</span><span class="p">]:</span>
                        <span class="n">df_bands</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df_bands</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="n">keys</span> <span class="o">=</span> <span class="n">df_bands</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;vals.shape: </span><span class="si">{</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">target_channels</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_channels</span><span class="p">)]</span>
                    <span class="n">new_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                    <span class="c1"># Map original channels to target channels</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="n">channel_map</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ch2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">ch2</span> <span class="ow">in</span> <span class="n">channel_map</span><span class="p">:</span>
                                    <span class="n">new_vals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">channel_map</span><span class="p">[</span><span class="n">ch1</span><span class="p">],</span> <span class="n">channel_map</span><span class="p">[</span><span class="n">ch2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cohere&quot;</span><span class="p">,</span> <span class="s2">&quot;zcohere&quot;</span><span class="p">,</span> <span class="s2">&quot;imcoh&quot;</span><span class="p">,</span> <span class="s2">&quot;zimcoh&quot;</span><span class="p">]:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">))</span> <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">new_vals</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_vals</span><span class="p">]</span>

                <span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">HIST_FEATURES</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>
                    <span class="n">new_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="o">*</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_channels</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channel_map</span><span class="p">:</span>
                            <span class="n">new_vals</span><span class="p">[:,</span> <span class="o">...</span><span class="p">,</span> <span class="n">channel_map</span><span class="p">[</span><span class="n">ch</span><span class="p">]]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                    <span class="n">result</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">))]</span>

                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid feature: </span><span class="si">{</span><span class="n">feature</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Old channel names: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="n">target_channels</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New channel names: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Old channel abbreviations: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update_instance_vars</span><span class="p">()</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New channel abbreviations: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.read_sars_spikes">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.read_sars_spikes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_sars_spikes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;SpikeAnalysisResult&quot;</span><span class="p">,</span> <span class="s2">&quot;FrequencyDomainSpikeAnalysisResult&quot;</span><span class="p">]],</span>
        <span class="n">read_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;sa&quot;</span><span class="p">,</span> <span class="s2">&quot;mne&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;sa&quot;</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate spike analysis results into WAR by adding nspike/lognspike features.</span>

<span class="sd">        This method extracts spike timing information from spike detection results and bins</span>
<span class="sd">        them according to the WAR&#39;s time windows, adding spike count features to each row.</span>

<span class="sd">        Args:</span>
<span class="sd">            sars: List of SpikeAnalysisResult or FrequencyDomainSpikeAnalysisResult objects.</span>
<span class="sd">                  One result per recording session (animalday).</span>
<span class="sd">            read_mode: Mode for extracting spike data:</span>
<span class="sd">                - &quot;sa&quot;: Read from SortingAnalyzer objects (result_sas attribute)</span>
<span class="sd">                - &quot;mne&quot;: Read from MNE RawArray objects (result_mne attribute)</span>
<span class="sd">            inplace: If True, modifies self.result and returns self.</span>
<span class="sd">                    If False, returns a new WindowAnalysisResult.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: WAR object with added spike features (nspike, lognspike).</span>
<span class="sd">                - If inplace=True: returns self with modified result DataFrame</span>
<span class="sd">                - If inplace=False: returns new WAR object with enhanced result DataFrame</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The number of sars must match the number of unique animaldays in self.result</span>
<span class="sd">            - Spikes are binned into time windows matching the existing WAR fragments</span>
<span class="sd">            - nspike: array of spike counts per channel for each time window</span>
<span class="sd">            - lognspike: log-transformed spike counts using core.log_transform()</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # After computing WAR and spike detection</span>
<span class="sd">            &gt;&gt;&gt; enhanced_war = war.read_sars_spikes(fdsar_list, read_mode=&quot;sa&quot;, inplace=False)</span>
<span class="sd">            &gt;&gt;&gt; enhanced_war.result[&#39;nspike&#39;]  # Spike counts per channel per window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">match</span> <span class="n">read_mode</span><span class="p">:</span>
            <span class="k">case</span> <span class="s2">&quot;sa&quot;</span><span class="p">:</span>
                <span class="n">spikes_all</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sar</span> <span class="ow">in</span> <span class="n">sars</span><span class="p">:</span>  <span class="c1"># for each continuous recording session</span>
                    <span class="n">spikes_channel</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sa</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sar</span><span class="o">.</span><span class="n">result_sas</span><span class="p">):</span>  <span class="c1"># for each channel</span>
                        <span class="n">spike_times</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">sa</span><span class="o">.</span><span class="n">sorting</span><span class="o">.</span><span class="n">get_unit_ids</span><span class="p">():</span>  <span class="c1"># Flatten units</span>
                            <span class="n">spike_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sa</span><span class="o">.</span><span class="n">sorting</span><span class="o">.</span><span class="n">get_unit_spike_train</span><span class="p">(</span><span class="n">unit_id</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span> <span class="o">/</span> <span class="n">sa</span><span class="o">.</span><span class="n">sorting</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">()</span>
                        <span class="n">spikes_channel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>
                    <span class="n">spikes_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spikes_channel</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_from_spikes_all</span><span class="p">(</span><span class="n">spikes_all</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
            <span class="k">case</span> <span class="s2">&quot;mne&quot;</span><span class="p">:</span>
                <span class="n">raws</span> <span class="o">=</span> <span class="p">[</span><span class="n">sar</span><span class="o">.</span><span class="n">result_mne</span> <span class="k">for</span> <span class="n">sar</span> <span class="ow">in</span> <span class="n">sars</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_mnes_spikes</span><span class="p">(</span><span class="n">raws</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
            <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid read_mode: </span><span class="si">{</span><span class="n">read_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.read_mnes_spikes">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.read_mnes_spikes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_mnes_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raws</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract spike features from MNE RawArray objects with spike annotations.</span>

<span class="sd">        This method extracts spike timing from MNE annotations (where spikes are marked</span>
<span class="sd">        with channel-specific event labels) and bins them into WAR time windows.</span>

<span class="sd">        Args:</span>
<span class="sd">            raws: List of MNE RawArray objects with spike annotations. One per recording</span>
<span class="sd">                  session (animalday). Each should have annotations with channel names</span>
<span class="sd">                  as event labels (e.g., &#39;LMot&#39;, &#39;RMot&#39;, etc.).</span>
<span class="sd">            inplace: If True, modifies self.result and returns self.</span>
<span class="sd">                    If False, returns a new WindowAnalysisResult.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: WAR object with added spike features (nspike, lognspike).</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Expects MNE annotations with channel names as event descriptions</span>
<span class="sd">            - Spike times are extracted from event onsets and binned to WAR windows</span>
<span class="sd">            - Channels not found in annotations will have empty spike arrays</span>
<span class="sd">            - Delegates to _read_from_spikes_all() for the actual binning logic</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # From MNE spike annotations</span>
<span class="sd">            &gt;&gt;&gt; enhanced_war = war.read_mnes_spikes([mne_raw1, mne_raw2], inplace=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spikes_all</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">raw</span> <span class="ow">in</span> <span class="n">raws</span><span class="p">:</span>
            <span class="c1"># each mne is a contiguous recording session</span>
            <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">events_from_annotations</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
            <span class="n">event_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">item</span><span class="p">():</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="n">spikes_channel</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">raw</span><span class="o">.</span><span class="n">ch_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">event_id</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> not found in event_id&quot;</span><span class="p">)</span>
                    <span class="n">spikes_channel</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="k">continue</span>
                <span class="n">event_id_channel</span> <span class="o">=</span> <span class="n">event_id</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="n">spike_times</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">event_id_channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">spike_times</span> <span class="o">=</span> <span class="n">spike_times</span> <span class="o">/</span> <span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">]</span>
                <span class="n">spikes_channel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>
            <span class="n">spikes_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spikes_channel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_from_spikes_all</span><span class="p">(</span><span class="n">spikes_all</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_read_from_spikes_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikes_all</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to bin spike times into WAR time windows and add as features.</span>

<span class="sd">        This is the common endpoint for both read_sars_spikes() and read_mnes_spikes().</span>
<span class="sd">        It bins spike times according to the WAR&#39;s time windows and adds nspike/lognspike</span>
<span class="sd">        features to the result DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            spikes_all: Nested list structure of spike times in seconds:</span>
<span class="sd">                - Outer list: recording sessions (one per animalday)</span>
<span class="sd">                - Middle list: channels (one per EEG channel)</span>
<span class="sd">                - Inner list/array: spike times in seconds for that channel</span>
<span class="sd">                Example: [[[0.5, 1.2], [0.8]], [[1.1, 2.3], []]]</span>
<span class="sd">                         = 2 sessions, 2 channels each</span>
<span class="sd">            inplace: If True, modifies self.result and returns self.</span>
<span class="sd">                    If False, returns a new WindowAnalysisResult with enhanced data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: WAR object with spike features added to result DataFrame.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Groups self.result by &#39;animalday&#39; and matches to spikes_all by index</span>
<span class="sd">            - Uses _bin_spike_df() helper to count spikes within each time window</span>
<span class="sd">            - Adds two new columns:</span>
<span class="sd">                - &#39;nspike&#39;: array of spike counts per channel for each window</span>
<span class="sd">                - &#39;lognspike&#39;: log-transformed spike counts via core.log_transform()</span>
<span class="sd">            - Warns if spike count size doesn&#39;t match result DataFrame size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Each groupby animalday is a recording session</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;animalday&quot;</span><span class="p">)</span>
        <span class="n">animaldays</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Animal days: </span><span class="si">{</span><span class="n">animaldays</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">spike_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">animaldays</span><span class="p">,</span> <span class="n">spikes_all</span><span class="p">))</span>
        <span class="n">spike_counts</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_bin_spike_df</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">spikes_channel</span><span class="o">=</span><span class="n">spike_counts</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
        <span class="n">spike_counts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="n">spike_counts</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">spike_counts</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spike counts size </span><span class="si">{</span><span class="n">spike_counts</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> does not match result size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;nspike&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spike_counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;lognspike&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">log_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;nspike&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create a new WindowAnalysisResult</span>
            <span class="n">new_war</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_war</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">new_war</span>

<div class="viewcode-block" id="WindowAnalysisResult.get_info">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a formatted string with basic information about the WindowAnalysisResult object&quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;feature names: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;animaldays: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;animalday&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;animal_id: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;animal&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;animal&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;genotype: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;genotype&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;genotype&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;channel_names: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;None&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_result">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_result">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get windowed analysis result dataframe, with helpful filters</span>

<span class="sd">        Args:</span>
<span class="sd">            features (list[str]): List of features to get from result</span>
<span class="sd">            exclude (list[str], optional): List of features to exclude from result; will override the features parameter. Defaults to [].</span>
<span class="sd">            allow_missing (bool, optional): If True, will return all requested features as columns regardless if they exist in result. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: DataFrame with features in columns and windows in rows</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">_sanitize_feature_request</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_missing</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonfeature_columns</span> <span class="o">+</span> <span class="n">features</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nonfeature_columns</span> <span class="o">+</span> <span class="n">features</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_groupavg_result">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_groupavg_result">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_groupavg_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="s2">&quot;animalday&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group result and average within groups. Preserves data structure and shape for each feature.</span>

<span class="sd">        Args:</span>
<span class="sd">            features (list[str]): List of features to get from result</span>
<span class="sd">            exclude (list[str], optional): List of features to exclude from result. Will override the features parameter. Defaults to [].</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            groupby (str, optional): Feature or list of features to group by before averaging. Passed to the `by` parameter in pd.DataFrame.groupby(). Defaults to &quot;animalday&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Result grouped by `groupby` and averaged for each group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_grouped</span><span class="p">,</span> <span class="n">result_validcols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_groups</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">)</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">_sanitize_feature_request</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

        <span class="n">avg_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">result_validcols</span><span class="p">:</span>
                <span class="n">avg_result_col</span> <span class="o">=</span> <span class="n">result_grouped</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_average_feature</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;duration&quot;</span><span class="p">,</span> <span class="n">include_groups</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">avg_result_col</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">f</span>
                <span class="n">avg_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">avg_result_col</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> not calculated, skipping&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">avg_results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__get_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="s2">&quot;animalday&quot;</span><span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">_sanitize_feature_request</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>
        <span class="n">result_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">df</span>
        <span class="k">return</span> <span class="n">result_win</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby</span><span class="p">),</span> <span class="n">result_win</span><span class="o">.</span><span class="n">columns</span>

<div class="viewcode-block" id="WindowAnalysisResult.get_grouprows_result">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_grouprows_result">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_grouprows_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">exclude</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">multiindex</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">,</span> <span class="s2">&quot;animal&quot;</span><span class="p">,</span> <span class="s2">&quot;genotype&quot;</span><span class="p">],</span>
        <span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">,</span> <span class="s2">&quot;endfile&quot;</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">_sanitize_feature_request</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>
        <span class="n">result_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">df</span>
        <span class="n">result_win</span> <span class="o">=</span> <span class="n">result_win</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">features</span> <span class="o">+</span> <span class="n">multiindex</span> <span class="o">+</span> <span class="n">include</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_win</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">multiindex</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_filter_logrms_range">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_filter_logrms_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_logrms_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">z_range</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter windows based on log(rms).</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            z_range (float, optional): The z-score range to filter by. Values outside this range will be set to NaN.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Boolean array of shape (M fragments, N channels). True = keep window, False = remove window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">z_range</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z_range</span><span class="p">)</span>
        <span class="n">np_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;rms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">np_logrms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np_rms</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">np_rms</span>
        <span class="n">np_logrmsz</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">np_logrms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s2">&quot;omit&quot;</span><span class="p">)</span>
        <span class="n">np_logrms</span><span class="p">[(</span><span class="n">np_logrmsz</span> <span class="o">&gt;</span> <span class="n">z_range</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">np_logrmsz</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">z_range</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">np_logrms</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[(</span><span class="n">np_logrmsz</span> <span class="o">&gt;</span> <span class="n">z_range</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">np_logrmsz</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">z_range</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_filter_high_rms">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_filter_high_rms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_high_rms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_rms</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter windows based on rms.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            max_rms (float, optional): The maximum rms value to filter by. Values above this will be set to NaN.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Boolean array of shape (M fragments, N channels). True = keep window, False = remove window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;rms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">np_rmsnan</span> <span class="o">=</span> <span class="n">np_rms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Convert to float to allow NaN assignment for integer arrays</span>
        <span class="k">if</span> <span class="n">np_rmsnan</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">):</span>  <span class="c1"># integer types</span>
            <span class="n">np_rmsnan</span> <span class="o">=</span> <span class="n">np_rmsnan</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">np_rmsnan</span><span class="p">[</span><span class="n">np_rms</span> <span class="o">&gt;</span> <span class="n">max_rms</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;rms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np_rmsnan</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">np_rms</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">np_rms</span> <span class="o">&gt;</span> <span class="n">max_rms</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_filter_low_rms">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_filter_low_rms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_low_rms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_rms</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter windows based on rms.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            min_rms (float, optional): The minimum rms value to filter by. Values below this will be set to NaN.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Boolean array of shape (M fragments, N channels). True = keep window, False = remove window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;rms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">np_rmsnan</span> <span class="o">=</span> <span class="n">np_rms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np_rmsnan</span><span class="p">[</span><span class="n">np_rms</span> <span class="o">&lt;</span> <span class="n">min_rms</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;rms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np_rmsnan</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">np_rms</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">np_rms</span> <span class="o">&lt;</span> <span class="n">min_rms</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_filter_high_beta">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_filter_high_beta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_high_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_beta_prop</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter windows based on beta power.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            max_beta_prop (float, optional): The maximum beta power to filter by. Values above this will be set to NaN. Defaults to 0.4.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Boolean array of shape (M fragments, N channels). True = keep window, False = remove window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;psdfrac&quot;</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df_psdfrac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;psdfrac&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">np_prop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df_psdfrac</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">elif</span> <span class="s2">&quot;psdband&quot;</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s2">&quot;psdtotal&quot;</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df_psdband</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;psdband&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">np_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df_psdband</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">np_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;psdtotal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">np_prop</span> <span class="o">=</span> <span class="n">np_beta</span> <span class="o">/</span> <span class="n">np_total</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;psdfrac or psdband+psdtotal required for beta power filtering&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">np_prop</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">np_prop</span> <span class="o">&gt;</span> <span class="n">max_beta_prop</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_filter_reject_channels">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_filter_reject_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_reject_channels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bad_channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_abbrevs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_bad_channels</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;overwrite&quot;</span><span class="p">,</span> <span class="s2">&quot;union&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;union&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter channels to reject.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            bad_channels (list[str]): List of channels to reject. Can be either full channel names or abbreviations.</span>
<span class="sd">                The method will automatically detect which format is being used. If None, no filtering is performed.</span>
<span class="sd">            use_abbrevs (bool, optional): Override automatic detection. If True, channels are assumed to be channel abbreviations. If False, channels are assumed to be channel names.</span>
<span class="sd">                If None, channels are parsed to abbreviations and matched against self.channel_abbrevs.</span>
<span class="sd">            save_bad_channels (Literal[&quot;overwrite&quot;, &quot;union&quot;, None], optional): How to save bad channels to self.bad_channels_dict.</span>
<span class="sd">                &quot;overwrite&quot;: Replace self.bad_channels_dict completely with bad channels applied to all sessions.</span>
<span class="sd">                &quot;union&quot;: Merge bad channels with existing self.bad_channels_dict for all sessions.</span>
<span class="sd">                None: Don&#39;t save to self.bad_channels_dict. Defaults to &quot;union&quot;.</span>
<span class="sd">                Note: When using &quot;overwrite&quot; mode, the bad_channels parameter and bad_channels_dict parameter</span>
<span class="sd">                may conflict and overwrite each other&#39;s bad channel definitions if both are provided.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Boolean array of shape (M fragments, N channels). True = keep window, False = remove window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bad_channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mask</span>

        <span class="n">channel_targets</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span> <span class="k">if</span> <span class="n">use_abbrevs</span> <span class="ow">or</span> <span class="n">use_abbrevs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span>
        <span class="p">)</span>  <span class="c1"># Match to appropriate target</span>
        <span class="k">if</span> <span class="n">use_abbrevs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Match channels as abbreviations</span>
            <span class="n">bad_channels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">core</span><span class="o">.</span><span class="n">parse_chname_to_abbrev</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">assume_from_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">bad_channels</span>
            <span class="p">]</span>

        <span class="c1"># Match channels to channel_targets</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">bad_channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channel_targets</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[:,</span> <span class="n">channel_targets</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2"> not found in </span><span class="si">{</span><span class="n">channel_targets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Save bad channels to self.bad_channels_dict if requested</span>
        <span class="k">if</span> <span class="n">save_bad_channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get all unique animal days from the result</span>
            <span class="n">animaldays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

            <span class="c1"># Convert bad channels to the format used in bad_channels_dict (original channel names)</span>
            <span class="n">channels_to_save</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">bad_channels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">use_abbrevs</span> <span class="ow">is</span> <span class="kc">False</span>
                <span class="k">else</span> <span class="p">[</span>
                    <span class="n">core</span><span class="o">.</span><span class="n">parse_chname_to_abbrev</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">assume_from_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">bad_channels</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">save_bad_channels</span> <span class="o">==</span> <span class="s2">&quot;overwrite&quot;</span><span class="p">:</span>
                <span class="c1"># Replace entire dict with bad channels applied to all sessions</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">animalday</span><span class="p">:</span> <span class="n">channels_to_save</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">animalday</span> <span class="ow">in</span> <span class="n">animaldays</span><span class="p">}</span>
            <span class="k">elif</span> <span class="n">save_bad_channels</span> <span class="o">==</span> <span class="s2">&quot;union&quot;</span><span class="p">:</span>
                <span class="c1"># Merge with existing bad channels for all sessions</span>
                <span class="n">updated_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">animalday</span> <span class="ow">in</span> <span class="n">animaldays</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">animalday</span> <span class="ow">in</span> <span class="n">updated_dict</span><span class="p">:</span>
                        <span class="c1"># Union of existing and new channels</span>
                        <span class="n">updated_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">updated_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">channels_to_save</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">updated_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels_to_save</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="n">updated_dict</span>

        <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_filter_reject_channels_by_recording_session">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_filter_reject_channels_by_recording_session">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_reject_channels_by_recording_session</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bad_channels_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_abbrevs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_bad_channels</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;overwrite&quot;</span><span class="p">,</span> <span class="s2">&quot;union&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;union&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter channels to reject for each recording session</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            bad_channels_dict (dict[str, list[str]]): Dictionary of list of channels to reject for each recording session.</span>
<span class="sd">                Can be either full channel names or abbreviations. The method will automatically detect which format is being used.</span>
<span class="sd">                If None, the method will use the bad_channels_dict passed to the constructor.</span>
<span class="sd">            use_abbrevs (bool, optional): Override automatic detection. If True, channels are assumed to be channel abbreviations. If False, channels are assumed to be channel names.</span>
<span class="sd">                If None, channels are parsed to abbreviations and matched against self.channel_abbrevs.</span>
<span class="sd">            save_bad_channels (Literal[&quot;overwrite&quot;, &quot;union&quot;, None], optional): How to save bad channels to self.bad_channels_dict.</span>
<span class="sd">                &quot;overwrite&quot;: Replace self.bad_channels_dict completely with bad_channels_dict.</span>
<span class="sd">                &quot;union&quot;: Merge bad_channels_dict with existing self.bad_channels_dict per session.</span>
<span class="sd">                None: Don&#39;t save to self.bad_channels_dict. Defaults to &quot;union&quot;.</span>
<span class="sd">                Note: When using &quot;overwrite&quot; mode, the bad_channels parameter and bad_channels_dict parameter</span>
<span class="sd">                may conflict and overwrite each other&#39;s bad channel definitions if both are provided.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Boolean array of shape (M fragments, N channels). True = keep window, False = remove window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bad_channels_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Group by animalday to apply filters per recording session</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;animalday&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bad_channels_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">animalday</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_channels_dict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No bad channels specified for recording session </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">. Check that all days are present in bad_channels_dict&quot;</span>
                    <span class="p">)</span>
                <span class="n">bad_channels</span> <span class="o">=</span> <span class="n">bad_channels_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_channels</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">channel_targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span> <span class="k">if</span> <span class="n">use_abbrevs</span> <span class="ow">or</span> <span class="n">use_abbrevs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span>
            <span class="k">if</span> <span class="n">use_abbrevs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bad_channels</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">core</span><span class="o">.</span><span class="n">parse_chname_to_abbrev</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">assume_from_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">bad_channels</span>
                <span class="p">]</span>

            <span class="c1"># Get indices for this recording session</span>
            <span class="n">session_indices</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span>

            <span class="c1"># Apply channel filtering for this session</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">bad_channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channel_targets</span><span class="p">:</span>
                    <span class="n">ch_idx</span> <span class="o">=</span> <span class="n">channel_targets</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">session_indices</span><span class="p">,</span> <span class="n">ch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2"> not found in </span><span class="si">{</span><span class="n">channel_targets</span><span class="si">}</span><span class="s2"> for session </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Save bad channels to self.bad_channels_dict if requested</span>
        <span class="k">if</span> <span class="n">save_bad_channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bad_channels_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">save_bad_channels</span> <span class="o">==</span> <span class="s2">&quot;overwrite&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">save_bad_channels</span> <span class="o">==</span> <span class="s2">&quot;union&quot;</span><span class="p">:</span>
                <span class="c1"># Merge with existing bad channels per session</span>
                <span class="n">updated_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">channels</span> <span class="ow">in</span> <span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">animalday</span> <span class="ow">in</span> <span class="n">updated_dict</span><span class="p">:</span>
                        <span class="c1"># Union of existing and new channels</span>
                        <span class="n">updated_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">updated_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">channels</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">updated_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="n">updated_dict</span>

        <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_filter_morphological_smoothing">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_filter_morphological_smoothing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_morphological_smoothing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filter_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">smoothing_seconds</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply morphological smoothing to a filter mask.</span>

<span class="sd">        Args:</span>
<span class="sd">            filter_mask (np.ndarray): Input boolean mask of shape (n_windows, n_channels)</span>
<span class="sd">            smoothing_seconds (float): Time window in seconds for morphological operations</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Smoothed boolean mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;duration&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate window duration - &#39;duration&#39; column missing&quot;</span><span class="p">)</span>

        <span class="n">window_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
        <span class="n">structure_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">smoothing_seconds</span> <span class="o">/</span> <span class="n">window_duration</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">structure_size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">filter_mask</span>

        <span class="n">smoothed_mask</span> <span class="o">=</span> <span class="n">filter_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">filter_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">channel_mask</span> <span class="o">=</span> <span class="n">filter_mask</span><span class="p">[:,</span> <span class="n">ch_idx</span><span class="p">]</span>
            <span class="c1"># Opening removes small isolated artifacts</span>
            <span class="n">channel_mask</span> <span class="o">=</span> <span class="n">binary_opening</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">structure_size</span><span class="p">))</span>
            <span class="c1"># Closing fills small gaps in valid data</span>
            <span class="n">channel_mask</span> <span class="o">=</span> <span class="n">binary_closing</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">structure_size</span><span class="p">))</span>
            <span class="n">smoothed_mask</span><span class="p">[:,</span> <span class="n">ch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_mask</span>

        <span class="k">return</span> <span class="n">smoothed_mask</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.filter_morphological_smoothing">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_morphological_smoothing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_morphological_smoothing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smoothing_seconds</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply morphological smoothing to all data.</span>

<span class="sd">        Args:</span>
<span class="sd">            smoothing_seconds (float): Time window in seconds for morphological operations</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start with all-True mask and smooth it</span>
        <span class="n">base_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">smoothed_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_morphological_smoothing</span><span class="p">(</span><span class="n">base_mask</span><span class="p">,</span> <span class="n">smoothing_seconds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">smoothed_mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.filter_all">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># bad_channels: list[str] = None,</span>
        <span class="n">min_valid_channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">morphological_smoothing_seconds</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># save_bad_channels: Literal[&quot;overwrite&quot;, &quot;union&quot;, None] = &quot;union&quot;,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a list of filters to the data. Filtering should be performed before aggregation.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame, optional): If not None, this function will use this dataframe instead of self.result. Defaults to None.</span>
<span class="sd">            inplace (bool, optional): If True, modify the result in place. Defaults to True.</span>
<span class="sd">            bad_channels (list[str], optional): List of channels to reject. Defaults to None.</span>
<span class="sd">            min_valid_channels (int, optional): Minimum number of valid channels required per window. Defaults to 3.</span>
<span class="sd">            filters (list[callable], optional): List of filter functions to apply. Each function should return a boolean mask.</span>
<span class="sd">                If None, uses default filters: [get_filter_logrms_range, get_filter_high_rms, get_filter_low_rms, get_filter_high_beta].</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            morphological_smoothing_seconds (float, optional): If provided, apply morphological opening/closing to smooth the filter mask.</span>
<span class="sd">                This removes isolated false positives/negatives along the time axis for each channel independently.</span>
<span class="sd">                The value specifies the time window in seconds for the morphological operations. Defaults to None.</span>
<span class="sd">            save_bad_channels (Literal[&quot;overwrite&quot;, &quot;union&quot;, None], optional): How to save bad channels to self.bad_channels_dict.</span>
<span class="sd">                This parameter is passed to the filtering functions. Defaults to &quot;union&quot;.</span>
<span class="sd">                Note: When using &quot;overwrite&quot; mode, the bad_channels parameter and bad_channels_dict parameter</span>
<span class="sd">                may conflict and overwrite each other&#39;s bad channel definitions if both are provided.</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to filter functions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: Filtered result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO refactor these into standalone functions, which take in a war as the first parameter, then pass</span>
            <span class="c1"># filt_bool = filt(self, df, **kwargs) as needed</span>
            <span class="n">filters</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_logrms_range</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_high_rms</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_low_rms</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_high_beta</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_reject_channels_by_recording_session</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_reject_channels</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="n">filt_bools</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Apply each filter function</span>
        <span class="k">for</span> <span class="n">filter_function</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">:</span>
            <span class="n">filt_bool</span> <span class="o">=</span> <span class="n">filter_function</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">filt_bools</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt_bool</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_function</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">:</span><span class="se">\t</span><span class="s2">filtered </span><span class="si">{</span><span class="n">filt_bool</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">filt_bool</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">filt_bool</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Apply all filters</span>
        <span class="n">filt_bool_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">filt_bools</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filt_bool_all.shape: </span><span class="si">{</span><span class="n">filt_bool_all</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (windows, channels)</span>

        <span class="c1"># Apply morphological smoothing if requested</span>
        <span class="k">if</span> <span class="n">morphological_smoothing_seconds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;duration&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate window duration - &#39;duration&#39; column missing from result dataframe&quot;</span><span class="p">)</span>
            <span class="n">window_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>

            <span class="c1"># Calculate number of windows for the smoothing</span>
            <span class="n">structure_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">morphological_smoothing_seconds</span> <span class="o">/</span> <span class="n">window_duration</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">structure_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Applying morphological smoothing with </span><span class="si">{</span><span class="n">structure_size</span><span class="si">}</span><span class="s2"> windows (</span><span class="si">{</span><span class="n">morphological_smoothing_seconds</span><span class="si">}</span><span class="s2">s / </span><span class="si">{</span><span class="n">window_duration</span><span class="si">}</span><span class="s2">s per window)&quot;</span>
                <span class="p">)</span>
                <span class="c1"># Apply channel-wise temporal smoothing (each channel processed independently)</span>
                <span class="c1"># This avoids spatial assumptions while smoothing temporal artifacts</span>
                <span class="k">for</span> <span class="n">ch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">filt_bool_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">channel_mask</span> <span class="o">=</span> <span class="n">filt_bool_all</span><span class="p">[:,</span> <span class="n">ch_idx</span><span class="p">]</span>
                    <span class="c1"># Opening removes small isolated artifacts</span>
                    <span class="n">channel_mask</span> <span class="o">=</span> <span class="n">binary_opening</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">structure_size</span><span class="p">))</span>
                    <span class="c1"># Closing fills small gaps in valid data</span>
                    <span class="n">channel_mask</span> <span class="o">=</span> <span class="n">binary_closing</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">structure_size</span><span class="p">))</span>
                    <span class="n">filt_bool_all</span><span class="p">[:,</span> <span class="n">ch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping morphological smoothing - structure size would be 1 (no effect)&quot;</span><span class="p">)</span>

        <span class="c1"># Filter windows based on number of valid channels</span>
        <span class="n">valid_channels_per_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filt_bool_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># axis 1 = channel</span>
        <span class="n">window_mask</span> <span class="o">=</span> <span class="n">valid_channels_per_window</span> <span class="o">&gt;=</span> <span class="n">min_valid_channels</span>  <span class="c1"># True if window has enough valid channels</span>
        <span class="n">filt_bool_all</span> <span class="o">=</span> <span class="n">filt_bool_all</span> <span class="o">&amp;</span> <span class="n">window_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># Apply window mask to all channels</span>

        <span class="n">filtered_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">filt_bool_all</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">filtered_result</span>
        <span class="k">return</span> <span class="n">WindowAnalysisResult</span><span class="p">(</span>
            <span class="n">filtered_result</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_filtered_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new WindowAnalysisResult with the filter applied.</span>

<span class="sd">        Args:</span>
<span class="sd">            filter_mask (np.ndarray): Boolean mask of shape (n_windows, n_channels)</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New instance with filter applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_filter</span><span class="p">(</span><span class="n">filter_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">WindowAnalysisResult</span><span class="p">(</span>
            <span class="n">filtered_result</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">)</span>

<div class="viewcode-block" id="WindowAnalysisResult.filter_logrms_range">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_logrms_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_logrms_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter based on log(rms) z-score range.</span>

<span class="sd">        Args:</span>
<span class="sd">            z_range (float): Z-score range threshold. Defaults to 3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_logrms_range</span><span class="p">(</span><span class="n">z_range</span><span class="o">=</span><span class="n">z_range</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.filter_high_rms">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_high_rms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_high_rms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rms</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out windows with RMS above threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_rms (float): Maximum RMS threshold. Defaults to 500.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_high_rms</span><span class="p">(</span><span class="n">max_rms</span><span class="o">=</span><span class="n">max_rms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.filter_low_rms">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_low_rms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_low_rms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_rms</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out windows with RMS below threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            min_rms (float): Minimum RMS threshold. Defaults to 50.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_low_rms</span><span class="p">(</span><span class="n">min_rms</span><span class="o">=</span><span class="n">min_rms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.filter_high_beta">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_high_beta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_high_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_beta_prop</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out windows with high beta power.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_beta_prop (float): Maximum beta power proportion. Defaults to 0.4.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_high_beta</span><span class="p">(</span><span class="n">max_beta_prop</span><span class="o">=</span><span class="n">max_beta_prop</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.filter_reject_channels">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_reject_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_reject_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bad_channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">use_abbrevs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out specified bad channels.</span>

<span class="sd">        Args:</span>
<span class="sd">            bad_channels (list[str]): List of channel names to reject</span>
<span class="sd">            use_abbrevs (bool, optional): Whether to use abbreviations. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_reject_channels</span><span class="p">(</span><span class="n">bad_channels</span><span class="o">=</span><span class="n">bad_channels</span><span class="p">,</span> <span class="n">use_abbrevs</span><span class="o">=</span><span class="n">use_abbrevs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.filter_reject_channels_by_session">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.filter_reject_channels_by_session">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_reject_channels_by_session</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">bad_channels_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_abbrevs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out bad channels by recording session.</span>

<span class="sd">        Args:</span>
<span class="sd">            bad_channels_dict (dict[str, list[str]], optional): Dictionary mapping recording session</span>
<span class="sd">                identifiers to lists of bad channel names to reject. Session identifiers are in the</span>
<span class="sd">                format &quot;{animal_id} {genotype} {day}&quot; (e.g., &quot;A10 WT Apr-01-2023&quot;). Channel names</span>
<span class="sd">                can be either full names (e.g., &quot;Left Auditory&quot;) or abbreviations (e.g., &quot;LAud&quot;).</span>
<span class="sd">                If None, uses the bad_channels_dict from the constructor. Defaults to None.</span>
<span class="sd">            use_abbrevs (bool, optional): Override automatic channel name format detection. If True,</span>
<span class="sd">                channels are assumed to be abbreviations. If False, channels are assumed to be full</span>
<span class="sd">                names. If None, automatically detects format and converts to abbreviations for matching.</span>
<span class="sd">                Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance with bad channels masked as NaN for their</span>
<span class="sd">                respective recording sessions</span>

<span class="sd">        Examples:</span>
<span class="sd">            Filter specific channels per session using abbreviations:</span>
<span class="sd">            &gt;&gt;&gt; bad_channels = {</span>
<span class="sd">            ...     &quot;A10 WT Apr-01-2023&quot;: [&quot;LAud&quot;, &quot;RMot&quot;],  # Session 1: reject left auditory, right motor</span>
<span class="sd">            ...     &quot;A10 WT Apr-02-2023&quot;: [&quot;LVis&quot;]           # Session 2: reject left visual only</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; filtered_war = war.filter_reject_channels_by_session(bad_channels, use_abbrevs=True)</span>

<span class="sd">            Filter using full channel names:</span>
<span class="sd">            &gt;&gt;&gt; bad_channels = {</span>
<span class="sd">            ...     &quot;A12 KO May-15-2023&quot;: [&quot;Left Motor&quot;, &quot;Right Barrel&quot;],</span>
<span class="sd">            ...     &quot;A12 KO May-16-2023&quot;: [&quot;Left Auditory&quot;, &quot;Left Visual&quot;, &quot;Right Motor&quot;]</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; filtered_war = war.filter_reject_channels_by_session(bad_channels, use_abbrevs=False)</span>

<span class="sd">            Auto-detect channel format (recommended):</span>
<span class="sd">            &gt;&gt;&gt; bad_channels = {</span>
<span class="sd">            ...     &quot;A15 WT Jun-10-2023&quot;: [&quot;LMot&quot;, &quot;RBar&quot;],  # Will auto-detect as abbreviations</span>
<span class="sd">            ...     &quot;A15 WT Jun-11-2023&quot;: [&quot;LAud&quot;]</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; filtered_war = war.filter_reject_channels_by_session(bad_channels)</span>

<span class="sd">        Note:</span>
<span class="sd">            - Session identifiers must exactly match the &quot;animalday&quot; values in the result DataFrame</span>
<span class="sd">            - Available channel abbreviations: LAud, RAud, LVis, RVis, LHip, RHip, LBar, RBar, LMot, RMot</span>
<span class="sd">            - Channel names are case-insensitive and support various formats (e.g., &quot;left aud&quot;, &quot;Left Auditory&quot;)</span>
<span class="sd">            - If a session identifier is not found in bad_channels_dict, a warning is logged but processing continues</span>
<span class="sd">            - If a channel name is not recognized, a warning is logged but other channels are still processed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_reject_channels_by_recording_session</span><span class="p">(</span>
            <span class="n">bad_channels_dict</span><span class="o">=</span><span class="n">bad_channels_dict</span><span class="p">,</span> <span class="n">use_abbrevs</span><span class="o">=</span><span class="n">use_abbrevs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.apply_filters">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.apply_filters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_filters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filter_config</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_valid_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">morphological_smoothing_seconds</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;WindowAnalysisResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply multiple filters using configuration.</span>

<span class="sd">        Args:</span>
<span class="sd">            filter_config (dict, optional): Dictionary of filter names and parameters.</span>
<span class="sd">                Available filters: &#39;logrms_range&#39;, &#39;high_rms&#39;, &#39;low_rms&#39;, &#39;high_beta&#39;,</span>
<span class="sd">                &#39;reject_channels&#39;, &#39;reject_channels_by_session&#39;, &#39;morphological_smoothing&#39;</span>
<span class="sd">            min_valid_channels (int): Minimum valid channels per window. Defaults to 3.</span>
<span class="sd">            morphological_smoothing_seconds (float, optional): Temporal smoothing window (deprecated, use config instead)</span>

<span class="sd">        Returns:</span>
<span class="sd">            WindowAnalysisResult: New filtered instance</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; config = {</span>
<span class="sd">            ...     &#39;logrms_range&#39;: {&#39;z_range&#39;: 3},</span>
<span class="sd">            ...     &#39;high_rms&#39;: {&#39;max_rms&#39;: 500},</span>
<span class="sd">            ...     &#39;reject_channels&#39;: {&#39;bad_channels&#39;: [&#39;LMot&#39;, &#39;RMot&#39;]},</span>
<span class="sd">            ...     &#39;morphological_smoothing&#39;: {&#39;smoothing_seconds&#39;: 8.0}</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; filtered_war = war.apply_filters(config)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;logrms_range&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;z_range&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                <span class="s2">&quot;high_rms&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;max_rms&quot;</span><span class="p">:</span> <span class="mi">500</span><span class="p">},</span>
                <span class="s2">&quot;low_rms&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;min_rms&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
                <span class="s2">&quot;high_beta&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;max_beta_prop&quot;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">},</span>
                <span class="s2">&quot;reject_channels_by_session&quot;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="p">}</span>

        <span class="n">filter_methods</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;logrms_range&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_logrms_range</span><span class="p">,</span>
            <span class="s2">&quot;high_rms&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_high_rms</span><span class="p">,</span>
            <span class="s2">&quot;low_rms&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_low_rms</span><span class="p">,</span>
            <span class="s2">&quot;high_beta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_high_beta</span><span class="p">,</span>
            <span class="s2">&quot;reject_channels&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_reject_channels</span><span class="p">,</span>
            <span class="s2">&quot;reject_channels_by_session&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_reject_channels_by_recording_session</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">filt_bools</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">morphological_params</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">filter_name</span><span class="p">,</span> <span class="n">filter_params</span> <span class="ow">in</span> <span class="n">filter_config</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">filter_name</span> <span class="o">==</span> <span class="s2">&quot;morphological_smoothing&quot;</span><span class="p">:</span>
                <span class="n">morphological_params</span> <span class="o">=</span> <span class="n">filter_params</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">filter_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filter_methods</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown filter: </span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">. Available: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">filter_methods</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;morphological_smoothing&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">filter_func</span> <span class="o">=</span> <span class="n">filter_methods</span><span class="p">[</span><span class="n">filter_name</span><span class="p">]</span>
            <span class="n">filt_bool</span> <span class="o">=</span> <span class="n">filter_func</span><span class="p">(</span><span class="o">**</span><span class="n">filter_params</span><span class="p">)</span>
            <span class="n">filt_bools</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt_bool</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">: filtered </span><span class="si">{</span><span class="n">filt_bool</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">filt_bool</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">filt_bool</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Combine all filter masks</span>
        <span class="k">if</span> <span class="n">filt_bools</span><span class="p">:</span>
            <span class="n">filt_bool_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">filt_bools</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filt_bool_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Apply morphological smoothing if requested (either from config or parameter)</span>
        <span class="k">if</span> <span class="n">morphological_params</span> <span class="ow">or</span> <span class="n">morphological_smoothing_seconds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">morphological_params</span><span class="p">:</span>
                <span class="n">smoothing_seconds</span> <span class="o">=</span> <span class="n">morphological_params</span><span class="p">[</span><span class="s2">&quot;smoothing_seconds&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">smoothing_seconds</span> <span class="o">=</span> <span class="n">morphological_smoothing_seconds</span>

            <span class="n">filt_bool_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_morphological_smoothing</span><span class="p">(</span><span class="n">filt_bool_all</span><span class="p">,</span> <span class="n">smoothing_seconds</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applied morphological smoothing: </span><span class="si">{</span><span class="n">smoothing_seconds</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="c1"># Filter windows based on minimum valid channels</span>
        <span class="n">valid_channels_per_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filt_bool_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">window_mask</span> <span class="o">=</span> <span class="n">valid_channels_per_window</span> <span class="o">&gt;=</span> <span class="n">min_valid_channels</span>
        <span class="n">filt_bool_all</span> <span class="o">=</span> <span class="n">filt_bool_all</span> <span class="o">&amp;</span> <span class="n">window_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_filtered_copy</span><span class="p">(</span><span class="n">filt_bool_all</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_tfs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">filter_tfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filter_tfs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># (M fragments, N channels)</span>
        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">FEATURES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2"> because it is not in result&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering </span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">match</span> <span class="n">feat</span><span class="p">:</span>  <span class="c1"># NOTE refactor this to use constants</span>
                <span class="k">case</span> <span class="s2">&quot;rms&quot;</span> <span class="o">|</span> <span class="s2">&quot;ampvar&quot;</span> <span class="o">|</span> <span class="s2">&quot;psdtotal&quot;</span> <span class="o">|</span> <span class="s2">&quot;nspike&quot;</span> <span class="o">|</span> <span class="s2">&quot;logrms&quot;</span> <span class="o">|</span> <span class="s2">&quot;logampvar&quot;</span> <span class="o">|</span> <span class="s2">&quot;logpsdtotal&quot;</span> <span class="o">|</span> <span class="s2">&quot;lognspike&quot;</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="c1"># Convert to float to allow NaN assignment for integer features</span>
                    <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">):</span>  <span class="c1"># integer types</span>
                        <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">filter_tfs</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">case</span> <span class="s2">&quot;psd&quot;</span><span class="p">:</span>
                    <span class="c1"># FIXME The sampling rates have changed between computation passes so WARs have different shapes.</span>
                    <span class="c1"># Add a check for same sampling frequency, other war-relevant properties etc.</span>
                    <span class="c1"># The logging lines below should be removed at some point, but I&#39;ll keep it this way for now</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;set([x[0].shape for x in result[feat].tolist()]) = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]))</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;set([x[1].shape for x in result[feat].tolist()]) = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]))</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">filter_tfs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">outs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">)]</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">outs</span>
                <span class="k">case</span> <span class="s2">&quot;psdband&quot;</span> <span class="o">|</span> <span class="s2">&quot;psdfrac&quot;</span> <span class="o">|</span> <span class="s2">&quot;logpsdband&quot;</span> <span class="o">|</span> <span class="s2">&quot;logpsdfrac&quot;</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">vals</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="n">v</span><span class="p">[</span><span class="o">~</span><span class="n">filter_tfs</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">vals</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="s2">&quot;records&quot;</span><span class="p">)</span>
                <span class="k">case</span> <span class="s2">&quot;psdslope&quot;</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">filter_tfs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="c1"># vals = [list(map(tuple, x)) for x in vals.tolist()]</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">case</span> <span class="s2">&quot;cohere&quot;</span> <span class="o">|</span> <span class="s2">&quot;zcohere&quot;</span> <span class="o">|</span> <span class="s2">&quot;imcoh&quot;</span> <span class="o">|</span> <span class="s2">&quot;zimcoh&quot;</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">filter_tfs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">vals</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="n">v</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">v</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">vals</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="s2">&quot;records&quot;</span><span class="p">)</span>
                <span class="k">case</span> <span class="s2">&quot;pcorr&quot;</span> <span class="o">|</span> <span class="s2">&quot;zpcorr&quot;</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">filter_tfs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown feature to filter </span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="WindowAnalysisResult.save_pickle_and_json">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.save_pickle_and_json">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_pickle_and_json</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">make_folder</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">slugify_filename</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_abbrevs_as_chnames</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Archive window analysis result into the folder specified, as a pickle and json file.</span>

<span class="sd">        Args:</span>
<span class="sd">            folder (str | Path): Destination folder to save results to</span>
<span class="sd">            make_folder (bool, optional): If True, create the folder if it doesn&#39;t exist. Defaults to True.</span>
<span class="sd">            filename (str, optional): Name of the file to save. Defaults to &quot;war&quot;.</span>
<span class="sd">            slugify_filename (bool, optional): If True, slugify the filename (replace special characters). Defaults to False.</span>
<span class="sd">            save_abbrevs_as_chnames (bool, optional): If True, save the channel abbreviations as the channel names in the json file. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">make_folder</span><span class="p">:</span>
            <span class="n">folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;war&quot;</span> <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">filename</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">slugify</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">if</span> <span class="n">slugify_filename</span> <span class="k">else</span> <span class="n">filename</span>

        <span class="n">filepath</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">folder</span> <span class="o">/</span> <span class="n">filename</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="n">filepath</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved WAR to </span><span class="si">{</span><span class="n">filepath</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;.pkl&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">json_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;animal_id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
            <span class="s2">&quot;genotype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
            <span class="s2">&quot;channel_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span> <span class="k">if</span> <span class="n">save_abbrevs_as_chnames</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
            <span class="s2">&quot;assume_from_number&quot;</span><span class="p">:</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">save_abbrevs_as_chnames</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
            <span class="s2">&quot;bad_channels_dict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="p">,</span>
            <span class="s2">&quot;suppress_short_interval_error&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span><span class="p">,</span>
            <span class="s2">&quot;lof_scores_dict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">}</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">json_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved WAR to </span><span class="si">{</span><span class="n">filepath</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;.json&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_bad_channels_by_lof_threshold">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_bad_channels_by_lof_threshold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_bad_channels_by_lof_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lof_threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply LOF threshold directly to stored scores to get bad channels.</span>

<span class="sd">        Args:</span>
<span class="sd">            lof_threshold (float): Threshold for determining bad channels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary mapping animal days to lists of bad channel names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;lof_scores_dict&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LOF scores not available in this WAR. Compute LOF scores first.&quot;</span><span class="p">)</span>

        <span class="n">bad_channels_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">lof_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;lof_scores&quot;</span> <span class="ow">in</span> <span class="n">lof_data</span> <span class="ow">and</span> <span class="s2">&quot;channel_names&quot;</span> <span class="ow">in</span> <span class="n">lof_data</span><span class="p">:</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lof_data</span><span class="p">[</span><span class="s2">&quot;lof_scores&quot;</span><span class="p">])</span>
                <span class="n">channel_names</span> <span class="o">=</span> <span class="n">lof_data</span><span class="p">[</span><span class="s2">&quot;channel_names&quot;</span><span class="p">]</span>

                <span class="n">is_inlier</span> <span class="o">=</span> <span class="n">scores</span> <span class="o">&lt;</span> <span class="n">lof_threshold</span>
                <span class="n">bad_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">is_inlier</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">bad_channels_dict</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_channels</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LOF scores not available for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bad_channels_dict</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.get_lof_scores">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.get_lof_scores">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_lof_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get LOF scores from this WAR.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary mapping animal days to LOF score dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;lof_scores_dict&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LOF scores not available in this WAR. Compute LOF scores first.&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">lof_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;lof_scores&quot;</span> <span class="ow">in</span> <span class="n">lof_data</span> <span class="ow">and</span> <span class="s2">&quot;channel_names&quot;</span> <span class="ow">in</span> <span class="n">lof_data</span><span class="p">:</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="n">lof_data</span><span class="p">[</span><span class="s2">&quot;lof_scores&quot;</span><span class="p">]</span>
                <span class="n">channel_names</span> <span class="o">=</span> <span class="n">lof_data</span><span class="p">[</span><span class="s2">&quot;channel_names&quot;</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">animalday</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">channel_names</span><span class="p">,</span> <span class="n">scores</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LOF scores not available for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.evaluate_lof_threshold_binary">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.evaluate_lof_threshold_binary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_lof_threshold_binary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ground_truth_bad_channels</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">evaluation_channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate single threshold against ground truth for binary classification.</span>

<span class="sd">        Args:</span>
<span class="sd">            ground_truth_bad_channels: Dict mapping animal-day to bad channel sets.</span>
<span class="sd">                                     If None, uses self.bad_channels_dict as ground truth.</span>
<span class="sd">            threshold: LOF threshold to test</span>
<span class="sd">            evaluation_channels: Subset of channels to include in evaluation. If none, uses all channels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: (y_true_list, y_pred_list) for sklearn.metrics.f1_score</span>
<span class="sd">                   Each element represents one channel from one animal-day</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;lof_scores_dict&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LOF scores not available in this WAR. Run compute_bad_channels() first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;threshold parameter is required&quot;</span><span class="p">)</span>

        <span class="c1"># Use self.bad_channels_dict as default ground truth</span>
        <span class="k">if</span> <span class="n">ground_truth_bad_channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bad_channels_dict&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="p">:</span>
                <span class="n">ground_truth_bad_channels</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># Filter bad_channels_dict to only include keys that exist in lof_scores_dict</span>
                <span class="n">lof_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">bad_channels_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

                <span class="n">missing_keys</span> <span class="o">=</span> <span class="n">bad_channels_keys</span> <span class="o">-</span> <span class="n">lof_keys</span>
                <span class="k">if</span> <span class="n">missing_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;bad_channels_dict contains keys not found in lof_scores_dict: </span><span class="si">{</span><span class="n">missing_keys</span><span class="si">}</span><span class="s2">. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Available LOF keys: </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lof_keys</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Only use bad channel keys that have corresponding LOF data</span>
                <span class="n">ground_truth_bad_channels</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_channels_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">lof_keys</span>
                <span class="p">}</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Using filtered bad_channels_dict as ground truth with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ground_truth_bad_channels</span><span class="p">)</span><span class="si">}</span><span class="s2"> animal-day sessions&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No ground truth provided and self.bad_channels_dict is empty.&quot;</span><span class="p">)</span>

        <span class="c1"># Get all channels if no subset specified</span>
        <span class="k">if</span> <span class="n">evaluation_channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">evaluation_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span>

        <span class="n">y_true_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y_pred_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Debug: Log what we&#39;re working with</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;evaluate_lof_threshold_binary: evaluation_channels = </span><span class="si">{</span><span class="n">evaluation_channels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;evaluate_lof_threshold_binary: ground_truth_bad_channels keys = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">ground_truth_bad_channels</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;evaluate_lof_threshold_binary: lof_scores_dict keys = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Iterate through each animal-day and evaluate channels</span>
        <span class="k">for</span> <span class="n">animalday</span><span class="p">,</span> <span class="n">lof_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lof_scores_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;lof_scores&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lof_data</span> <span class="ow">or</span> <span class="s2">&quot;channel_names&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lof_data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid LOF data for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">: missing required fields &#39;lof_scores&#39; or &#39;channel_names&#39;&quot;</span>
                <span class="p">)</span>

            <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lof_data</span><span class="p">[</span><span class="s2">&quot;lof_scores&quot;</span><span class="p">])</span>
            <span class="n">channel_names</span> <span class="o">=</span> <span class="n">lof_data</span><span class="p">[</span><span class="s2">&quot;channel_names&quot;</span><span class="p">]</span>

            <span class="c1"># Get ground truth bad channels for this animal-day</span>
            <span class="n">animalday_bad_channels</span> <span class="o">=</span> <span class="n">ground_truth_bad_channels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">animalday</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

            <span class="c1"># Debug: Log details for this animal-day</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">: channel_names = </span><span class="si">{</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">: animalday_bad_channels = </span><span class="si">{</span><span class="n">animalday_bad_channels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">: scores shape = </span><span class="si">{</span><span class="n">scores</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Evaluate each channel in the evaluation subset</span>
            <span class="n">channels_processed</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">channel</span> <span class="ow">in</span> <span class="n">evaluation_channels</span>
                    <span class="ow">or</span> <span class="n">parse_chname_to_abbrev</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">strict_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">in</span> <span class="n">evaluation_channels</span>
                <span class="p">):</span>
                    <span class="n">channels_processed</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Ground truth: 1 if channel is marked as bad, 0 otherwise</span>
                    <span class="n">is_bad_channel</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">channel</span> <span class="ow">in</span> <span class="n">animalday_bad_channels</span>
                        <span class="ow">or</span> <span class="n">parse_chname_to_abbrev</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">strict_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">in</span> <span class="n">animalday_bad_channels</span>
                    <span class="p">)</span>
                    <span class="c1"># if is_bad_channel and channel not in animalday_bad_channels:</span>
                    <span class="c1">#     logging.debug(f&quot;Mapped full channel &#39;{channel}&#39; -&gt; &#39;{parse_chname_to_abbrev(channel, strict_matching=False)}&#39; found in bad channels&quot;)</span>

                    <span class="n">y_true</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">is_bad_channel</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="c1"># Prediction: 1 if LOF score &gt; threshold, 0 otherwise</span>
                    <span class="n">y_pred</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="mi">0</span>

                    <span class="n">y_true_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_true</span><span class="p">)</span>
                    <span class="n">y_pred_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>

                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: y_true=</span><span class="si">{</span><span class="n">y_true</span><span class="si">}</span><span class="s2">, y_pred=</span><span class="si">{</span><span class="n">y_pred</span><span class="si">}</span><span class="s2"> (score=</span><span class="si">{</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, threshold=</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>

                    <span class="c1"># Extra debugging for the alignment issue</span>
                    <span class="k">if</span> <span class="n">y_true</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;TRUE POSITIVE CANDIDATE: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> mapped to bad channel in: </span><span class="si">{</span><span class="n">animalday_bad_channels</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">y_pred</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LOF PREDICTION: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> has score </span><span class="si">{</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> &gt; threshold </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed </span><span class="si">{</span><span class="n">channels_processed</span><span class="si">}</span><span class="s2"> channels for </span><span class="si">{</span><span class="n">animalday</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y_true_list</span><span class="p">,</span> <span class="n">y_pred_list</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.load_pickle_and_json">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.load_pickle_and_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_pickle_and_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pickle_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">json_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load WindowAnalysisResult from folder</span>

<span class="sd">        Args:</span>
<span class="sd">            folder_path (str, optional): Path of folder containing .pkl and .json files. Defaults to None.</span>
<span class="sd">            pickle_name (str, optional): Name of the pickle file. Can be just the filename (e.g. &quot;war.pkl&quot;)</span>
<span class="sd">                or a path relative to folder_path (e.g. &quot;subdir/war.pkl&quot;). If None and folder_path is provided,</span>
<span class="sd">                expects exactly one .pkl file in folder_path. Defaults to None.</span>
<span class="sd">            json_name (str, optional): Name of the JSON file. Can be just the filename (e.g. &quot;war.json&quot;)</span>
<span class="sd">                or a path relative to folder_path (e.g. &quot;subdir/war.json&quot;). If None and folder_path is provided,</span>
<span class="sd">                expects exactly one .json file in folder_path. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: folder_path does not exist</span>
<span class="sd">            ValueError: Expected exactly one pickle and one json file in folder_path (when pickle_name/json_name not specified)</span>
<span class="sd">            FileNotFoundError: Specified pickle_name or json_name not found</span>

<span class="sd">        Returns:</span>
<span class="sd">            result: WindowAnalysisResult object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">folder_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">folder_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder path </span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pickle_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Handle pickle_name as either absolute path or relative to folder_path</span>
                <span class="n">pickle_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pickle_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pickle_path</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">():</span>
                    <span class="n">df_pickle_path</span> <span class="o">=</span> <span class="n">pickle_path</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df_pickle_path</span> <span class="o">=</span> <span class="n">folder_path</span> <span class="o">/</span> <span class="n">pickle_name</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">df_pickle_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pickle file not found: </span><span class="si">{</span><span class="n">df_pickle_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pkl_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.pkl&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pkl_files</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected exactly one pickle file in </span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pkl_files</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">df_pickle_path</span> <span class="o">=</span> <span class="n">pkl_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">json_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Handle json_name as either absolute path or relative to folder_path</span>
                <span class="n">json_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">json_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">json_path</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">():</span>
                    <span class="n">json_path</span> <span class="o">=</span> <span class="n">json_path</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">json_path</span> <span class="o">=</span> <span class="n">folder_path</span> <span class="o">/</span> <span class="n">json_name</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">json_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JSON file not found: </span><span class="si">{</span><span class="n">json_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">json_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.json&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_files</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected exactly one json file in </span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2">, found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">json_files</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">json_path</span> <span class="o">=</span> <span class="n">json_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pickle_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">json_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Either folder_path must be provided, or both pickle_name and json_name must be provided as absolute paths&quot;</span>
                <span class="p">)</span>

            <span class="n">df_pickle_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pickle_name</span><span class="p">)</span>
            <span class="n">json_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">json_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">df_pickle_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pickle file not found: </span><span class="si">{</span><span class="n">df_pickle_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">json_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JSON file not found: </span><span class="si">{</span><span class="n">json_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">df_pickle_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">metadata</span><span class="p">)</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.aggregate_time_windows">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.aggregate_time_windows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">aggregate_time_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupby</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">,</span> <span class="s2">&quot;isday&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aggregate time windows into a single data point per groupby by averaging features. This reduces the number of rows in the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            groupby (list[str] | str, optional): Columns to group by. Defaults to [&#39;animalday&#39;, &#39;isday&#39;], which groups by animalday (recording session) and isday (day/night).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: groupby must be from [&#39;animalday&#39;, &#39;isday&#39;]</span>
<span class="sd">            ValueError: Columns in groupby not found in result</span>
<span class="sd">            ValueError: Columns in groupby are not constant in groups</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupby</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">groupby</span> <span class="o">=</span> <span class="p">[</span><span class="n">groupby</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">,</span> <span class="s2">&quot;isday&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;groupby must be from [&#39;animalday&#39;, &#39;isday&#39;]. Got </span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Columns </span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2"> not found in result. Columns: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">FEATURES</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Aggregating </span><span class="si">{</span><span class="n">features</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result_grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby</span><span class="p">)</span>

        <span class="n">agg_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="s2">&quot;animalday&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;isday&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="s2">&quot;isday&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="kc">None</span>

        <span class="n">constant_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;animal&quot;</span><span class="p">,</span> <span class="s2">&quot;day&quot;</span><span class="p">,</span> <span class="s2">&quot;genotype&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">constant_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">is_constant</span> <span class="o">=</span> <span class="n">result_grouped</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_constant</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">non_constant_groups</span> <span class="o">=</span> <span class="n">is_constant</span><span class="p">[</span><span class="o">~</span><span class="n">is_constant</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> is not constant in groups: </span><span class="si">{</span><span class="n">non_constant_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">agg_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;duration&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s2">&quot;endfile&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="s2">&quot;endfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;endfile&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;timestamp&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">agg_dict</span><span class="p">[</span><span class="n">feat</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">feat</span><span class="o">=</span><span class="n">feat</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_feature</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="s2">&quot;duration&quot;</span><span class="p">)</span>

        <span class="n">aggregated_df</span> <span class="o">=</span> <span class="n">result_grouped</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="n">col</span><span class="p">:</span> <span class="n">agg_dict</span><span class="p">[</span><span class="n">col</span><span class="p">](</span><span class="n">df</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">})</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">aggregated_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Keep animalday/isday as a column</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_short_interval_error</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Setting suppress_short_interval_error to True&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update_instance_vars</span><span class="p">()</span></div>


<div class="viewcode-block" id="WindowAnalysisResult.add_unique_hash">
<a class="viewcode-back" href="../../../api/visualization/window_analysis_result.html#neurodent.visualization.WindowAnalysisResult.add_unique_hash">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_unique_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a hex hash to the animal ID to ensure uniqueness. This prevents collisions when, for example, multiple animals in ExperimentPlotter have the same animal ID.</span>

<span class="sd">        Args:</span>
<span class="sd">            nbytes (int, optional): Number of bytes to generate. This is passed directly to secrets.token_hex(). Defaults to None, which generates 16 hex characters (8 bytes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">secrets</span>

        <span class="n">hash_suffix</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">token_hex</span><span class="p">(</span><span class="n">nbytes</span><span class="p">)</span>
        <span class="n">new_animal_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">hash_suffix</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;animal&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;animal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_animal_id</span>
        <span class="k">if</span> <span class="s2">&quot;animalday&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;animalday&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span> <span class="n">new_animal_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span> <span class="o">=</span> <span class="n">new_animal_id</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__update_instance_vars</span><span class="p">()</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">bin_spike_times</span><span class="p">(</span><span class="n">spike_times</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">fragment_durations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bin spike times into counts based on fragment durations.</span>

<span class="sd">    Args:</span>
<span class="sd">        spike_times (list[float]): List of spike timestamps in seconds</span>
<span class="sd">        fragment_durations (list[float]): List of fragment durations in seconds</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[int]: List of spike counts per fragment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert fragment durations to bin edges</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">fragment_durations</span><span class="p">)</span>

    <span class="c1"># Use numpy&#39;s histogram function to count spikes in each bin</span>
    <span class="n">counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_bin_spike_df</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">spikes_channel</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bins spike times into a matrix of shape (n_windows, n_channels), based on duration of each window in df</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">durations</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">durations</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikes_channel</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spike_times</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikes_channel</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_spike_times</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="SpikeAnalysisResult">
<a class="viewcode-back" href="../../../api/visualization/spike_analysis_result.html#neurodent.visualization.SpikeAnalysisResult">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpikeAnalysisResult</span><span class="p">(</span><span class="n">AnimalFeatureParser</span><span class="p">):</span>
<div class="viewcode-block" id="SpikeAnalysisResult.__init__">
<a class="viewcode-back" href="../../../api/visualization/spike_analysis_result.html#neurodent.visualization.SpikeAnalysisResult.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">result_sas</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">SortingAnalyzer</span><span class="p">],</span>
        <span class="n">result_mne</span><span class="p">:</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">animal_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">genotype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">animal_day</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bin_folder_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">DDFBinaryMetadata</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channel_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">assume_from_number</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            result (list[si.SortingAnalyzer]): Result comes from AnimalOrganizer.compute_spike_analysis(). Each SortingAnalyzer is a single channel.</span>
<span class="sd">            animal_id (str, optional): Identifier for the animal where result was computed from. Defaults to None.</span>
<span class="sd">            genotype (str, optional): Genotype of animal. Defaults to None.</span>
<span class="sd">            channel_names (list[str], optional): List of channel names. Defaults to None.</span>
<span class="sd">            assume_channels (bool, optional): If true, assumes channel names according to AnimalFeatureParser.DEFAULT_CHNUM_TO_NAME. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_sas</span> <span class="o">=</span> <span class="n">result_sas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_mne</span> <span class="o">=</span> <span class="n">result_mne</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result_mne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">result_sas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Exactly one of result_sas or result_mne must be provided&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span> <span class="o">=</span> <span class="n">animal_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span> <span class="o">=</span> <span class="n">genotype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animal_day</span> <span class="o">=</span> <span class="n">animal_day</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_name</span> <span class="o">=</span> <span class="n">bin_folder_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span> <span class="o">=</span> <span class="n">channel_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span> <span class="o">=</span> <span class="n">assume_from_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">core</span><span class="o">.</span><span class="n">parse_chname_to_abbrev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">assume_from_number</span><span class="o">=</span><span class="n">assume_from_number</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span>
        <span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel names: </span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel abbreviations: </span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpikeAnalysisResult.convert_to_mne">
<a class="viewcode-back" href="../../../api/visualization/spike_analysis_result.html#neurodent.visualization.SpikeAnalysisResult.convert_to_mne">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_to_mne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">save_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_mne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result_mne</span> <span class="o">=</span> <span class="n">SpikeAnalysisResult</span><span class="o">.</span><span class="n">convert_sas_to_mne</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_sas</span><span class="p">,</span> <span class="n">chunk_len</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save_raw</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">result_mne</span> <span class="o">=</span> <span class="n">result_mne</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result_mne</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_mne</span></div>


<div class="viewcode-block" id="SpikeAnalysisResult.save_fif_and_json">
<a class="viewcode-back" href="../../../api/visualization/spike_analysis_result.html#neurodent.visualization.SpikeAnalysisResult.save_fif_and_json">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_fif_and_json</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">convert_to_mne</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">make_folder</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">slugify_filebase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">save_abbrevs_as_chnames</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Archive spike analysis result into the folder specified, as a fif and json file.</span>

<span class="sd">        Args:</span>
<span class="sd">            folder (str | Path): Destination folder to save results to</span>
<span class="sd">            convert_to_mne (bool, optional): If True, convert the SortingAnalyzers to a MNE RawArray if self.result_mne is None. Defaults to True.</span>
<span class="sd">            make_folder (bool, optional): If True, create the folder if it doesn&#39;t exist. Defaults to True.</span>
<span class="sd">            slugify_filebase (bool, optional): If True, slugify the filebase (replace special characters). Defaults to True.</span>
<span class="sd">            save_abbrevs_as_chnames (bool, optional): If True, save the channel abbreviations as the channel names in the json file. Defaults to False.</span>
<span class="sd">            overwrite (bool, optional): If True, overwrite the existing files. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_mne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">convert_to_mne</span><span class="p">:</span>
                <span class="n">result_mne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_mne</span><span class="p">(</span><span class="n">save_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result_mne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No SortingAnalyzers found, skipping saving&quot;</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No MNE RawArray found, and convert_to_mne is False. Run convert_to_mne() first.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_mne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_mne</span>

        <span class="n">folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">make_folder</span><span class="p">:</span>
            <span class="n">folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">slugify_filebase</span><span class="p">:</span>
            <span class="n">filebase</span> <span class="o">=</span> <span class="n">folder</span> <span class="o">/</span> <span class="n">slugify</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_day</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filebase</span> <span class="o">=</span> <span class="n">folder</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">animal_day</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">filebase</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filebase</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filebase</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span> <span class="ow">in</span> <span class="n">folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.json&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">filebase</span><span class="si">}</span><span class="s2">.json already exists&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filebase</span> <span class="o">+</span> <span class="s2">&quot;.fif&quot;</span> <span class="ow">in</span> <span class="n">folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.fif&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">filebase</span><span class="si">}</span><span class="s2">.fif already exists&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="n">result_mne</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filebase</span> <span class="o">+</span> <span class="s2">&quot;-raw.fif&quot;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">result_mne</span>

        <span class="n">json_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;animal_id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">animal_id</span><span class="p">,</span>
            <span class="s2">&quot;genotype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype</span><span class="p">,</span>
            <span class="s2">&quot;animal_day&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">animal_day</span><span class="p">,</span>
            <span class="s2">&quot;bin_folder_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_folder_name</span><span class="p">,</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">metadata_path</span><span class="p">,</span>
            <span class="s2">&quot;channel_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_abbrevs</span> <span class="k">if</span> <span class="n">save_abbrevs_as_chnames</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">,</span>
            <span class="s2">&quot;assume_from_number&quot;</span><span class="p">:</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">save_abbrevs_as_chnames</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">assume_from_number</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filebase</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">json_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpikeAnalysisResult.load_fif_and_json">
<a class="viewcode-back" href="../../../api/visualization/spike_analysis_result.html#neurodent.visualization.SpikeAnalysisResult.load_fif_and_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_fif_and_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span><span class="p">):</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">folder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Folder </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>

        <span class="n">fif_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.fif&quot;</span><span class="p">))</span>  <span class="c1"># there may be more than 1 fif file</span>
        <span class="n">json_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.json&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_files</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected exactly one json file in </span><span class="si">{</span><span class="n">folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">fif_path</span> <span class="o">=</span> <span class="n">fif_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">json_path</span> <span class="o">=</span> <span class="n">json_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># data[&#39;metadata&#39;] = core.DDFBinaryMetadata(data[&#39;metadata&#39;])</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;result_mne&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_raw_fif</span><span class="p">(</span><span class="n">fif_path</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;result_sas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpikeAnalysisResult.convert_sas_to_mne">
<a class="viewcode-back" href="../../../api/visualization/spike_analysis_result.html#neurodent.visualization.SpikeAnalysisResult.convert_sas_to_mne">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_sas_to_mne</span><span class="p">(</span><span class="n">sas</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">SortingAnalyzer</span><span class="p">],</span> <span class="n">chunk_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a list of SortingAnalyzers to a MNE RawArray.</span>

<span class="sd">        Args:</span>
<span class="sd">            sas (list[si.SortingAnalyzer]): The list of SortingAnalyzers to convert</span>
<span class="sd">            chunk_len (float, optional): The length of the chunks to use for the conversion. Defaults to 60.</span>

<span class="sd">        Returns:</span>
<span class="sd">            mne.io.RawArray: The converted RawArray, with spikes labeled as annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Check that all SortingAnalyzers have the same sampling frequency</span>
        <span class="n">sfreqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sa</span><span class="o">.</span><span class="n">recording</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">()</span> <span class="k">for</span> <span class="n">sa</span> <span class="ow">in</span> <span class="n">sas</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">sf</span> <span class="o">==</span> <span class="n">sfreqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sfreqs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All SortingAnalyzers must have the same sampling frequency. Got frequencies: </span><span class="si">{</span><span class="n">sfreqs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Preallocate data array</span>
        <span class="n">total_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">recording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span> <span class="o">*</span> <span class="n">sfreqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sas</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">total_frames</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data shape: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Fill data array one channel at a time</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sa</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sas</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting channel </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">n_channels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">SpikeAnalysisResult</span><span class="o">.</span><span class="n">convert_sa_to_np</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">chunk_len</span><span class="p">)</span>

        <span class="n">channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sa</span><span class="o">.</span><span class="n">recording</span><span class="o">.</span><span class="n">get_channel_ids</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="k">for</span> <span class="n">sa</span> <span class="ow">in</span> <span class="n">sas</span><span class="p">]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel names: </span><span class="si">{</span><span class="n">channel_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sfreq</span> <span class="o">=</span> <span class="n">sfreqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Extract spike times for each unit and create annotations</span>
        <span class="n">onset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">description</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sa</span> <span class="ow">in</span> <span class="n">sas</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">unit_id</span> <span class="ow">in</span> <span class="n">sa</span><span class="o">.</span><span class="n">sorting</span><span class="o">.</span><span class="n">get_unit_ids</span><span class="p">():</span>
                <span class="n">spike_train</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="n">sorting</span><span class="o">.</span><span class="n">get_unit_spike_train</span><span class="p">(</span><span class="n">unit_id</span><span class="p">)</span>
                <span class="c1"># Convert to seconds and filter to recording duration</span>
                <span class="n">spike_times</span> <span class="o">=</span> <span class="n">spike_train</span> <span class="o">/</span> <span class="n">sa</span><span class="o">.</span><span class="n">sorting</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">()</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">spike_times</span> <span class="o">&lt;</span> <span class="n">sa</span><span class="o">.</span><span class="n">recording</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span>
                <span class="n">spike_times</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

                <span class="c1"># Create annotation for each spike</span>
                <span class="n">onset</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>
                <span class="n">description</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">sa</span><span class="o">.</span><span class="n">recording</span><span class="o">.</span><span class="n">get_channel_ids</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># collapse all units into 1 spike train</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">Annotations</span><span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>

        <span class="n">info</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">create_info</span><span class="p">(</span><span class="n">ch_names</span><span class="o">=</span><span class="n">channel_names</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="n">sfreq</span><span class="p">,</span> <span class="n">ch_types</span><span class="o">=</span><span class="s2">&quot;eeg&quot;</span><span class="p">)</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">set_annotations</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">raw</span></div>


<div class="viewcode-block" id="SpikeAnalysisResult.convert_sa_to_np">
<a class="viewcode-back" href="../../../api/visualization/spike_analysis_result.html#neurodent.visualization.SpikeAnalysisResult.convert_sa_to_np">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_sa_to_np</span><span class="p">(</span><span class="n">sa</span><span class="p">:</span> <span class="n">si</span><span class="o">.</span><span class="n">SortingAnalyzer</span><span class="p">,</span> <span class="n">chunk_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a SortingAnalyzer to an MNE RawArray.</span>

<span class="sd">        Args:</span>
<span class="sd">            sa (si.SortingAnalyzer): The SortingAnalyzer to convert. Must have only 1 channel.</span>
<span class="sd">            chunk_len (float, optional): The length of the chunks to use for the conversion. Defaults to 60.</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The converted traces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that SortingAnalyzer only has 1 channel</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sa</span><span class="o">.</span><span class="n">recording</span><span class="o">.</span><span class="n">get_channel_ids</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected SortingAnalyzer to have 1 channel, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sa</span><span class="o">.</span><span class="n">recording</span><span class="o">.</span><span class="n">get_channel_ids</span><span class="p">())</span><span class="si">}</span><span class="s2"> channels&quot;</span>
            <span class="p">)</span>

        <span class="n">rec</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="n">recording</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recording info: </span><span class="si">{</span><span class="n">rec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate total number of frames and chunks</span>
        <span class="n">total_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">get_duration</span><span class="p">()</span> <span class="o">*</span> <span class="n">rec</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">())</span>
        <span class="n">frames_per_chunk</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">chunk_len</span> <span class="o">*</span> <span class="n">rec</span><span class="o">.</span><span class="n">get_sampling_frequency</span><span class="p">())</span>
        <span class="n">n_chunks</span> <span class="o">=</span> <span class="n">total_frames</span> <span class="o">//</span> <span class="n">frames_per_chunk</span>

        <span class="n">traces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_frames</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chunks</span><span class="p">):</span>
            <span class="n">start_frame</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">frames_per_chunk</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n_chunks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end_frame</span> <span class="o">=</span> <span class="n">total_frames</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">frames_per_chunk</span>
            <span class="n">traces</span><span class="p">[</span><span class="n">start_frame</span><span class="p">:</span><span class="n">end_frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">get_traces</span><span class="p">(</span>
                <span class="n">start_frame</span><span class="o">=</span><span class="n">start_frame</span><span class="p">,</span> <span class="n">end_frame</span><span class="o">=</span><span class="n">end_frame</span><span class="p">,</span> <span class="n">return_scaled</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">traces</span> <span class="o">*=</span> <span class="mf">1e-6</span>  <span class="c1"># convert from uV to V</span>
        <span class="k">return</span> <span class="n">traces</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Joseph Dong, Yongtaek Oh, Eric Marsh.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>